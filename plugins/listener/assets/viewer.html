<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Viewer</title>
  <script src="https://cdn.twind.style" crossorigin></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@tanstack/react-query@4/build/umd/index.production.js"></script>
</head>
<body class="bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 text-gray-100 h-screen overflow-hidden">
  <div id="app"></div>

  <script type="module">
    import htm from 'https://esm.sh/htm';
    
    const FILE_OPTIONS = [
      "council_011320_2022003V",
      "f7952672-5d18-4f75-8aa0-74ab8b02dac3",
      "14b0f420-81e0-4104-b16a-585f1b1b0b56"
    ];
    
    const html = htm.bind(React.createElement);
    const { useState, useEffect, useRef } = React;
    const { QueryClient, QueryClientProvider, useQuery } = ReactQuery;
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          refetchOnWindowFocus: false,
          retry: 1,
        },
      },
    });

    const App = () => {
      const [currentIndex, setCurrentIndex] = useState(0);
      const [selectedFile, setSelectedFile] = useState(FILE_OPTIONS[0]);
      const [stepSize, setStepSize] = useState(1);
      const contentRef = useRef(null);

      const { data = [], isLoading, isError, error } = useQuery({
        queryKey: ['diffData', selectedFile],
        queryFn: async () => {
          const response = await fetch(`./diff/${selectedFile}.json`);
          if (!response.ok) {
            throw new Error('Failed to load file');
          }
          return response.json();
        },
        onSuccess: () => {
          setCurrentIndex(0);
        },
      });

      useEffect(() => {
        const handleKeydown = (e) => {
          if (e.key === 'ArrowLeft') {
            setCurrentIndex(prev => Math.max(0, prev - stepSize));
          } else if (e.key === 'ArrowRight') {
            setCurrentIndex(prev => Math.min(data.length - 1, prev + stepSize));
          }
        };
        
        window.addEventListener('keydown', handleKeydown);
        return () => window.removeEventListener('keydown', handleKeydown);
      }, [currentIndex, data.length, stepSize]);

      useEffect(() => {
        if (contentRef.current) {
          contentRef.current.scrollTop = contentRef.current.scrollHeight;
        }
      }, [currentIndex]);

      const collectWords = () => {
        const allWords = [];
        
        for (let i = 0; i < currentIndex && i < data.length; i++) {
          Object.entries(data[i].final_words || {}).forEach(([key, words]) => {
            words.forEach(word => {
              allWords.push({
                ...word,
                type: 'final',
                frameIndex: i,
                channelKey: key
              });
            });
          });
        }
        
        if (data[currentIndex]) {
          Object.entries(data[currentIndex].final_words || {}).forEach(([key, words]) => {
            words.forEach(word => {
              allWords.push({
                ...word,
                type: 'final',
                frameIndex: currentIndex,
                channelKey: key
              });
            });
          });
          
          Object.entries(data[currentIndex].partial_words || {}).forEach(([key, words]) => {
            words.forEach(word => {
              allWords.push({
                ...word,
                type: 'partial',
                frameIndex: currentIndex,
                channelKey: key
              });
            });
          });
        }
        
        return allWords;
      };

      const createSpeakerSegments = (words) => {
        if (words.length === 0) return [];
        
        words.sort((a, b) => a.start - b.start);
        
        const segments = [];
        let currentSegment = null;
        
        words.forEach(word => {
          const speaker = word.speaker ?? 'unknown';
          
          if (!currentSegment || currentSegment.speaker !== speaker) {
            currentSegment = {
              speaker: speaker,
              words: [word]
            };
            segments.push(currentSegment);
          } else {
            currentSegment.words.push(word);
          }
        });
        
        return segments;
      };

      const getSpeakerColor = (speaker) => {
        const colors = [
          'text-blue-400',
          'text-green-400',
          'text-yellow-400',
          'text-purple-400',
          'text-pink-400',
          'text-indigo-400',
          'text-orange-400',
          'text-teal-400'
        ];
        
        if (speaker === 'unknown') return 'text-gray-400';
        return colors[speaker % colors.length];
      };

      const renderContent = () => {
        if (isLoading) {
          return html`<span class="text-gray-500 italic">Loading...</span>`;
        }
        
        if (isError) {
          return html`<span class="text-red-400 italic">Error: ${error.message}</span>`;
        }
        
        const words = collectWords();
        const segments = createSpeakerSegments(words);
        
        if (segments.length === 0) {
          return html`<span class="text-gray-500 italic">No content to display</span>`;
        }
        
        return html`
          <div class="space-y-3">
            ${segments.map((segment, segIndex) => html`
              <div key=${segIndex} class="flex gap-3">
                <div class="flex-shrink-0 w-12 text-right">
                  <span class="${getSpeakerColor(segment.speaker)} font-bold">
                    ${segment.speaker === 'unknown' ? '?' : segment.speaker}:
                  </span>
                </div>
                <div class="flex-1 leading-relaxed">
                  ${segment.words.map((word, wordIndex) => html`
                    <span key=${wordIndex} class="${word.type === 'final' ? 'text-rose-400' : 'text-emerald-400'} font-medium">
                      ${wordIndex > 0 ? ' ' : ''}${word.word}
                    </span>
                  `)}
                </div>
              </div>
            `)}
          </div>
        `;
      };

      return html`
        <div class="h-screen flex flex-col p-6">
          <div class="bg-gray-800/50 backdrop-blur-sm rounded-xl border border-gray-700/50 p-4 mb-4">
            <div class="flex items-center justify-between flex-wrap gap-4">
              <div class="flex items-center gap-3">
                <label class="text-sm text-gray-400 font-medium">File:</label>
                <select 
                  value=${selectedFile}
                  onChange=${e => setSelectedFile(e.target.value)}
                  class="bg-gray-900/50 border border-gray-600 rounded-lg px-4 py-2 text-gray-100 hover:bg-gray-900/70 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500/50"
                >
                  ${FILE_OPTIONS.map(file => html`
                    <option key=${file} value=${file}>${file}</option>
                  `)}
                </select>
              </div>

              <div class="flex items-center gap-3">
                <button 
                  onClick=${() => setCurrentIndex(Math.max(0, currentIndex - stepSize))}
                  disabled=${currentIndex === 0 || isLoading}
                  class="bg-gray-900/50 hover:bg-gray-900/70 px-4 py-2 rounded-lg border border-gray-600 transition-all ${(currentIndex === 0 || isLoading) ? 'opacity-40 cursor-not-allowed' : 'hover:border-blue-500/50'}"
                  title="Previous (← arrow key)"
                >
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                  </svg>
                </button>
                
                <div class="bg-gray-900/50 px-4 py-2 rounded-lg border border-gray-600 min-w-[100px] text-center">
                  ${isLoading ? html`
                    <span class="text-sm text-gray-400">Loading...</span>
                  ` : html`
                    <span class="text-sm font-semibold text-blue-400">
                      ${data.length > 0 ? `${currentIndex + 1}` : '0'}
                    </span>
                    <span class="text-sm text-gray-400"> / ${data.length}</span>
                  `}
                </div>
                
                <button 
                  onClick=${() => setCurrentIndex(Math.min(data.length - 1, currentIndex + stepSize))}
                  disabled=${currentIndex >= data.length - 1 || isLoading}
                  class="bg-gray-900/50 hover:bg-gray-900/70 px-4 py-2 rounded-lg border border-gray-600 transition-all ${(currentIndex >= data.length - 1 || isLoading) ? 'opacity-40 cursor-not-allowed' : 'hover:border-blue-500/50'}"
                  title="Next (→ arrow key)"
                >
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                  </svg>
                </button>

                <div class="flex items-center gap-2 ml-2 px-3 py-1 bg-gray-900/50 rounded-lg border border-gray-600">
                  <label class="text-xs text-gray-400">Step:</label>
                  <select 
                    value=${stepSize}
                    onChange=${e => setStepSize(Number(e.target.value))}
                    class="bg-transparent text-sm text-gray-100 focus:outline-none"
                  >
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="4">4</option>
                    <option value="8">8</option>
                  </select>
                </div>
              </div>

              <div class="flex items-center gap-4 text-sm">
                <div class="flex items-center gap-2">
                  <div class="w-3 h-3 bg-rose-400 rounded-full"></div>
                  <span class="text-gray-300">Final</span>
                </div>
                <div class="flex items-center gap-2">
                  <div class="w-3 h-3 bg-emerald-400 rounded-full"></div>
                  <span class="text-gray-300">Partial</span>
                </div>
              </div>
            </div>
          </div>
          
          <div class="flex-1 bg-gray-800/30 backdrop-blur-sm rounded-xl border border-gray-700/50 p-8 overflow-hidden flex flex-col">
            <div ref=${contentRef} class="flex-1 overflow-y-auto scroll-smooth">
              <div class="font-mono text-lg text-gray-100">
                ${renderContent()}
              </div>
            </div>
          </div>

          <div class="mt-3 text-center text-xs text-gray-500">
            ${isLoading ? 'Loading data...' : 'Use arrow keys (← →) for navigation • Step size controls how many items to skip'}
          </div>
        </div>
      `;
    };

    const Root = () => {
      return html`
        <${QueryClientProvider} client=${queryClient}>
          <${App} />
        <//>
      `;
    };

    ReactDOM.render(html`<${Root} />`, document.getElementById('app'));
  </script>
</body>
</html>
