---
description: Code style conventions and best practices for Hyprnote development
globs:
  - "**/*.ts"
  - "**/*.tsx"
  - "**/*.rs"
  - "**/*.js"
  - "**/*.jsx"
alwaysApply: false
---

# Code Style and Conventions

## TypeScript/React Conventions

### Naming Conventions
- **Files**: kebab-case (e.g., `session-store.ts`, `audio-utils.tsx`)
- **Components**: PascalCase (e.g., `SessionManager`, `AudioRecorder`)
- **Hooks**: Prefix with `use` (e.g., `useSession`, `useAudioState`)
- **Constants**: UPPER_SNAKE_CASE for true constants

### Code Style
- Functional components with TypeScript strict mode
- Use React hooks and avoid class components
- Custom hooks for reusable logic
- Zustand for global state management
- TanStack Query (React Query) for server state
- Avoid `any` types - use proper TypeScript types

### File Organization
- Place tests next to source files with `.test.ts` or `.spec.ts` suffix
- Group related components in feature folders
- Shared utilities in `packages/utils/`

## Rust Conventions

The project follows the [official Rust Style Guide](https://doc.rust-lang.org/stable/style-guide/) enforced by `rustfmt`.

### Core Style Principles
- **Readability first**: Code should be scannable and accessible
- **Consistency**: Uniform formatting across the codebase
- **Expression-oriented**: Prefer expressions over statements
- **Explicit over implicit**: Clear intent in code structure

### Formatting Rules (via rustfmt)
- **Indentation**: 4 spaces (no tabs)
- **Line width**: Maximum 100 characters
- **Trailing commas**: Required in multi-line constructs
- **Blank lines**: One between top-level items, zero within items

### Naming Conventions
| Item | Convention | Example |
|------|------------|---------|
| Types, Traits | `UpperCamelCase` | `AudioProcessor`, `StreamHandler` |
| Enum variants | `UpperCamelCase` | `ProcessingState::Active` |
| Functions, Methods | `snake_case` | `process_audio()`, `get_buffer()` |
| Variables, Fields | `snake_case` | `audio_buffer`, `sample_rate` |
| Constants, Statics | `SCREAMING_SNAKE_CASE` | `MAX_BUFFER_SIZE` |
| Lifetimes | Short lowercase | `'a`, `'buf` |
| Type parameters | Concise uppercase | `T`, `K`, `V` |
| Crate names | `snake_case` | `hypr_audio` |

### Import Organization
```rust
// Group order: std → external → internal → self/super
use std::collections::HashMap;
use std::sync::Arc;

use tokio::sync::Mutex;
use tracing::{debug, info};

use crate::audio::AudioBuffer;
use crate::processor::Processor;

use super::config::Config;
```

### Function Formatting
```rust
// Single-line for simple signatures
fn simple_function(x: i32, y: i32) -> i32 {
    x + y
}

// Multi-line for complex signatures
fn process_audio_buffer<T>(
    buffer: &mut [T],
    config: &ProcessingConfig,
    callback: impl Fn(&T) -> T,
) -> Result<(), ProcessingError>
where
    T: Sample + Send + Sync,
{
    // implementation
}
```

### Struct and Enum Formatting
```rust
// Simple struct
struct Point {
    x: f64,
    y: f64,
}

// Complex struct with derives
#[derive(Debug, Clone, PartialEq)]
pub struct AudioConfig {
    pub sample_rate: u32,
    pub channels: u16,
    pub buffer_size: usize,
}

// Enum with variants
pub enum ProcessingState {
    Idle,
    Active { start_time: Instant },
    Error(String),
}
```

### Error Handling Patterns
```rust
// Using thiserror for error types
#[derive(thiserror::Error, Debug)]
pub enum AudioError {
    #[error("Device initialization failed: {0}")]
    InitFailed(String),
    
    #[error("Buffer overflow at position {position}")]
    BufferOverflow { position: usize },
    
    #[error("Invalid sample rate: {0}")]
    InvalidSampleRate(u32),
}

// Result type alias for cleaner signatures
pub type AudioResult<T> = Result<T, AudioError>;
```

### Expression-Oriented Style
```rust
// Prefer expressions
let status = if buffer.is_empty() {
    ProcessingStatus::Idle
} else {
    ProcessingStatus::Active
};

// Use match as expression
let message = match result {
    Ok(data) => format!("Success: {} items", data.len()),
    Err(e) => format!("Error: {}", e),
};
```

### Documentation Standards
```rust
/// Processes audio buffer with given configuration.
///
/// # Arguments
/// * `buffer` - Audio samples to process
/// * `config` - Processing configuration
///
/// # Returns
/// Processed audio buffer or error
///
/// # Example
/// ```
/// let processed = process_audio(&buffer, &config)?;
/// ```
pub fn process_audio(
    buffer: &[f32],
    config: &Config,
) -> Result<Vec<f32>, AudioError> {
    // implementation
}
```

### Module Organization
```rust
//! Audio processing module
//!
//! This module provides real-time audio processing capabilities.

mod buffer;
mod processor;
mod utils;

pub use buffer::AudioBuffer;
pub use processor::{Processor, ProcessorConfig};

// Re-export commonly used items
pub use self::utils::{db_to_linear, linear_to_db};
```

### Async Patterns
```rust
// Async function with proper error handling
pub async fn stream_audio(
    source: AudioSource,
) -> Result<AudioStream, StreamError> {
    let connection = source.connect().await?;
    let stream = connection.start_stream().await?;
    Ok(stream)
}

// Using tokio for concurrent operations
use tokio::sync::mpsc;
use tokio::task;

let (tx, rx) = mpsc::channel(100);
let handle = task::spawn(async move {
    process_stream(rx).await
});
```

### Testing Patterns
```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_audio_processing() {
        let buffer = vec![0.0; 1024];
        let result = process_audio(&buffer, &Config::default());
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_async_streaming() {
        let source = AudioSource::mock();
        let stream = stream_audio(source).await;
        assert!(stream.is_ok());
    }
}
```

### Performance Best Practices
- Use `&str` instead of `&String` in function parameters
- Prefer `&[T]` over `&Vec<T>` for slice parameters
- Use `Box<dyn Error>` sparingly, prefer concrete error types
- Leverage zero-copy operations with `Cow<'_, T>`
- Use `const fn` for compile-time computations

### Platform-Specific Code
```rust
#[cfg(target_os = "macos")]
mod macos {
    pub fn init_audio() -> Result<(), Error> {
        // macOS-specific implementation
    }
}

#[cfg(target_os = "windows")]
mod windows {
    pub fn init_audio() -> Result<(), Error> {
        // Windows-specific implementation
    }
}
```

## Formatting Rules

### TypeScript/JavaScript
- Handled by dprint
- Single body position: nextLine for functions
- 2 spaces indentation
- Single quotes for strings

### Rust
- Handled by rustfmt
- Edition 2021
- Follows official Rust Style Guide

### Cargo.toml Formatting
```toml
# [package] section at top
[package]
name = "hypr-audio"
version = "0.1.0"
edition = "2021"
authors = ["Hyprnote Team"]
description = "Audio processing library for Hyprnote"

# Dependencies section with version-sorted keys
[dependencies]
anyhow = "1.0"
tokio = { version = "1.35", features = ["full"] }
tracing = "0.1"

# Dev dependencies
[dev-dependencies]
criterion = "0.5"
proptest = "1.4"

# Features with arrays on multiple lines for clarity
[features]
default = ["native"]
native = [
    "dep:cpal",
    "dep:dasp",
]
```

### Markdown
- Formatted by dprint
- Includes `.jinja` templates and documentation

## Comments and Documentation

### TypeScript
- JSDoc comments for public APIs
- Inline comments for complex logic
- Avoid obvious comments

### Rust
- Doc comments (`///`) for public items
- Module-level documentation with `//!`
- Examples in doc comments where helpful
- SAFETY comments for unsafe blocks

## Import Organization

### TypeScript
1. External imports (npm packages)
2. Internal package imports (@hypr/*)
3. Relative imports (./...)
4. Type imports last

### Rust
1. Standard library imports
2. External crate imports
3. Internal crate imports
4. Module imports (use super::*, use crate::*)

## Platform-Specific Code
- Use feature flags for platform-specific Rust code
- Target-specific dependencies in Cargo.toml
- Platform modules (e.g., `audio::macos`, `audio::windows`)
- Clear abstractions over platform differences