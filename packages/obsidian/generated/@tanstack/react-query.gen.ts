// This file is auto-generated by @hey-api/openapi-ts

import { type Options, get, deleteActive, getActive, patchActive, postActive, putActive, getCommands, postCommandsByCommandId, postOpenByFilename, deletePeriodicByPeriod, getPeriodicByPeriod, patchPeriodicByPeriod, postPeriodicByPeriod, putPeriodicByPeriod, postSearch, postSearchSimple, getVault, deleteVaultByFilename, getVaultByFilename, patchVaultByFilename, postVaultByFilename, putVaultByFilename, getVaultByPathToDirectory } from '../sdk.gen';
import { queryOptions, type UseMutationOptions, type DefaultError } from '@tanstack/react-query';
import type { GetData, DeleteActiveData, DeleteActiveError, DeleteActiveResponse, GetActiveData, PatchActiveData, PatchActiveError, PostActiveData, PostActiveError, PostActiveResponse, PutActiveData, PutActiveError, PutActiveResponse, GetCommandsData, PostCommandsByCommandIdData, PostCommandsByCommandIdError, PostCommandsByCommandIdResponse, PostOpenByFilenameData, DeletePeriodicByPeriodData, DeletePeriodicByPeriodError, DeletePeriodicByPeriodResponse, GetPeriodicByPeriodData, PatchPeriodicByPeriodData, PatchPeriodicByPeriodError, PostPeriodicByPeriodData, PostPeriodicByPeriodError, PostPeriodicByPeriodResponse, PutPeriodicByPeriodData, PutPeriodicByPeriodError, PutPeriodicByPeriodResponse, PostSearchData, PostSearchError, PostSearchResponse, PostSearchSimpleData, PostSearchSimpleResponse, GetVaultData, DeleteVaultByFilenameData, DeleteVaultByFilenameError, DeleteVaultByFilenameResponse, GetVaultByFilenameData, PatchVaultByFilenameData, PatchVaultByFilenameError, PostVaultByFilenameData, PostVaultByFilenameError, PostVaultByFilenameResponse, PutVaultByFilenameData, PutVaultByFilenameError, PutVaultByFilenameResponse, GetVaultByPathToDirectoryData } from '../types.gen';
import { client as _heyApiClient } from '../client.gen';

type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): QueryKey<TOptions>[0] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: (options?.client ?? _heyApiClient).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return params;
};

export const getQueryKey = (options?: Options<GetData>) => [
    createQueryKey('get', options)
];

export const getOptions = (options?: Options<GetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await get({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getQueryKey(options)
    });
};

export const deleteActiveMutation = (options?: Partial<Options<DeleteActiveData>>) => {
    const mutationOptions: UseMutationOptions<DeleteActiveResponse, DeleteActiveError, Options<DeleteActiveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteActive({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getActiveQueryKey = (options?: Options<GetActiveData>) => [
    createQueryKey('getActive', options)
];

export const getActiveOptions = (options?: Options<GetActiveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getActive({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getActiveQueryKey(options)
    });
};

export const patchActiveMutation = (options?: Partial<Options<PatchActiveData>>) => {
    const mutationOptions: UseMutationOptions<unknown, PatchActiveError, Options<PatchActiveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await patchActive({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postActiveQueryKey = (options: Options<PostActiveData>) => [
    createQueryKey('postActive', options)
];

export const postActiveOptions = (options: Options<PostActiveData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postActive({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postActiveQueryKey(options)
    });
};

export const postActiveMutation = (options?: Partial<Options<PostActiveData>>) => {
    const mutationOptions: UseMutationOptions<PostActiveResponse, PostActiveError, Options<PostActiveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postActive({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const putActiveMutation = (options?: Partial<Options<PutActiveData>>) => {
    const mutationOptions: UseMutationOptions<PutActiveResponse, PutActiveError, Options<PutActiveData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putActive({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCommandsQueryKey = (options?: Options<GetCommandsData>) => [
    createQueryKey('getCommands', options)
];

export const getCommandsOptions = (options?: Options<GetCommandsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCommands({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCommandsQueryKey(options)
    });
};

export const postCommandsByCommandIdQueryKey = (options: Options<PostCommandsByCommandIdData>) => [
    createQueryKey('postCommandsByCommandId', options)
];

export const postCommandsByCommandIdOptions = (options: Options<PostCommandsByCommandIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postCommandsByCommandId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postCommandsByCommandIdQueryKey(options)
    });
};

export const postCommandsByCommandIdMutation = (options?: Partial<Options<PostCommandsByCommandIdData>>) => {
    const mutationOptions: UseMutationOptions<PostCommandsByCommandIdResponse, PostCommandsByCommandIdError, Options<PostCommandsByCommandIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postCommandsByCommandId({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postOpenByFilenameQueryKey = (options: Options<PostOpenByFilenameData>) => [
    createQueryKey('postOpenByFilename', options)
];

export const postOpenByFilenameOptions = (options: Options<PostOpenByFilenameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postOpenByFilename({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postOpenByFilenameQueryKey(options)
    });
};

export const postOpenByFilenameMutation = (options?: Partial<Options<PostOpenByFilenameData>>) => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<PostOpenByFilenameData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postOpenByFilename({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deletePeriodicByPeriodMutation = (options?: Partial<Options<DeletePeriodicByPeriodData>>) => {
    const mutationOptions: UseMutationOptions<DeletePeriodicByPeriodResponse, DeletePeriodicByPeriodError, Options<DeletePeriodicByPeriodData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deletePeriodicByPeriod({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPeriodicByPeriodQueryKey = (options: Options<GetPeriodicByPeriodData>) => [
    createQueryKey('getPeriodicByPeriod', options)
];

export const getPeriodicByPeriodOptions = (options: Options<GetPeriodicByPeriodData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPeriodicByPeriod({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPeriodicByPeriodQueryKey(options)
    });
};

export const patchPeriodicByPeriodMutation = (options?: Partial<Options<PatchPeriodicByPeriodData>>) => {
    const mutationOptions: UseMutationOptions<unknown, PatchPeriodicByPeriodError, Options<PatchPeriodicByPeriodData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await patchPeriodicByPeriod({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postPeriodicByPeriodQueryKey = (options: Options<PostPeriodicByPeriodData>) => [
    createQueryKey('postPeriodicByPeriod', options)
];

export const postPeriodicByPeriodOptions = (options: Options<PostPeriodicByPeriodData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postPeriodicByPeriod({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postPeriodicByPeriodQueryKey(options)
    });
};

export const postPeriodicByPeriodMutation = (options?: Partial<Options<PostPeriodicByPeriodData>>) => {
    const mutationOptions: UseMutationOptions<PostPeriodicByPeriodResponse, PostPeriodicByPeriodError, Options<PostPeriodicByPeriodData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postPeriodicByPeriod({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const putPeriodicByPeriodMutation = (options?: Partial<Options<PutPeriodicByPeriodData>>) => {
    const mutationOptions: UseMutationOptions<PutPeriodicByPeriodResponse, PutPeriodicByPeriodError, Options<PutPeriodicByPeriodData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putPeriodicByPeriod({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postSearchQueryKey = (options: Options<PostSearchData>) => [
    createQueryKey('postSearch', options)
];

export const postSearchOptions = (options: Options<PostSearchData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postSearch({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postSearchQueryKey(options)
    });
};

export const postSearchMutation = (options?: Partial<Options<PostSearchData>>) => {
    const mutationOptions: UseMutationOptions<PostSearchResponse, PostSearchError, Options<PostSearchData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postSearch({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postSearchSimpleQueryKey = (options: Options<PostSearchSimpleData>) => [
    createQueryKey('postSearchSimple', options)
];

export const postSearchSimpleOptions = (options: Options<PostSearchSimpleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postSearchSimple({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postSearchSimpleQueryKey(options)
    });
};

export const postSearchSimpleMutation = (options?: Partial<Options<PostSearchSimpleData>>) => {
    const mutationOptions: UseMutationOptions<PostSearchSimpleResponse, DefaultError, Options<PostSearchSimpleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postSearchSimple({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getVaultQueryKey = (options?: Options<GetVaultData>) => [
    createQueryKey('getVault', options)
];

export const getVaultOptions = (options?: Options<GetVaultData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVault({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVaultQueryKey(options)
    });
};

export const deleteVaultByFilenameMutation = (options?: Partial<Options<DeleteVaultByFilenameData>>) => {
    const mutationOptions: UseMutationOptions<DeleteVaultByFilenameResponse, DeleteVaultByFilenameError, Options<DeleteVaultByFilenameData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteVaultByFilename({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getVaultByFilenameQueryKey = (options: Options<GetVaultByFilenameData>) => [
    createQueryKey('getVaultByFilename', options)
];

export const getVaultByFilenameOptions = (options: Options<GetVaultByFilenameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVaultByFilename({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVaultByFilenameQueryKey(options)
    });
};

export const patchVaultByFilenameMutation = (options?: Partial<Options<PatchVaultByFilenameData>>) => {
    const mutationOptions: UseMutationOptions<unknown, PatchVaultByFilenameError, Options<PatchVaultByFilenameData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await patchVaultByFilename({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const postVaultByFilenameQueryKey = (options: Options<PostVaultByFilenameData>) => [
    createQueryKey('postVaultByFilename', options)
];

export const postVaultByFilenameOptions = (options: Options<PostVaultByFilenameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await postVaultByFilename({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: postVaultByFilenameQueryKey(options)
    });
};

export const postVaultByFilenameMutation = (options?: Partial<Options<PostVaultByFilenameData>>) => {
    const mutationOptions: UseMutationOptions<PostVaultByFilenameResponse, PostVaultByFilenameError, Options<PostVaultByFilenameData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await postVaultByFilename({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const putVaultByFilenameMutation = (options?: Partial<Options<PutVaultByFilenameData>>) => {
    const mutationOptions: UseMutationOptions<PutVaultByFilenameResponse, PutVaultByFilenameError, Options<PutVaultByFilenameData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await putVaultByFilename({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getVaultByPathToDirectoryQueryKey = (options: Options<GetVaultByPathToDirectoryData>) => [
    createQueryKey('getVaultByPathToDirectory', options)
];

export const getVaultByPathToDirectoryOptions = (options: Options<GetVaultByPathToDirectoryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVaultByPathToDirectory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVaultByPathToDirectoryQueryKey(options)
    });
};