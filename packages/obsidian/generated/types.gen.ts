// This file is auto-generated by @hey-api/openapi-ts

export type _Error = {
    /**
     * A 5-digit error code uniquely identifying this particular type of error.
     *
     */
    errorCode?: number;
    /**
     * Message describing the error.
     */
    message?: string;
};

export type NoteJson = {
    content: string;
    frontmatter: {
        [key: string]: unknown;
    };
    path: string;
    stat: {
        ctime: number;
        mtime: number;
        size: number;
    };
    tags: Array<string>;
};

export type GetData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/';
};

export type GetResponses = {
    /**
     * Success
     */
    200: {
        /**
         * Is your current request authenticated?
         */
        authenticated?: boolean;
        /**
         * 'OK'
         */
        ok?: string;
        /**
         * 'Obsidian Local REST API'
         */
        service?: string;
        versions?: {
            /**
             * Obsidian plugin API version
             */
            obsidian?: string;
            /**
             * Plugin version.
             */
            self?: string;
        };
    };
};

export type GetResponse = GetResponses[keyof GetResponses];

export type DeleteActiveData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/active/';
};

export type DeleteActiveErrors = {
    /**
     * File does not exist.
     */
    404: _Error;
    /**
     * Your path references a directory instead of a file; this request method is valid only for updating files.
     *
     */
    405: _Error;
};

export type DeleteActiveError = DeleteActiveErrors[keyof DeleteActiveErrors];

export type DeleteActiveResponses = {
    /**
     * Success
     */
    204: void;
};

export type DeleteActiveResponse = DeleteActiveResponses[keyof DeleteActiveResponses];

export type GetActiveData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/active/';
};

export type GetActiveErrors = {
    /**
     * File does not exist
     */
    404: unknown;
};

export type GetActiveResponses = {
    /**
     * Success
     */
    200: NoteJson;
};

export type GetActiveResponse = GetActiveResponses[keyof GetActiveResponses];

export type PatchActiveData = {
    /**
     * Content you would like to insert.
     */
    body: string;
    headers: {
        /**
         * Patch operation to perform
         */
        Operation: 'append' | 'prepend' | 'replace';
        /**
         * Type of target to patch
         */
        'Target-Type': 'heading' | 'block' | 'frontmatter';
        /**
         * Delimiter to use for nested targets (i.e. Headings)
         */
        'Target-Delimiter'?: string;
        /**
         * Target to patch; this value can be URL-Encoded and *must*
         * be URL-Encoded if it includes non-ASCII characters.
         *
         */
        Target: string;
        /**
         * Trim whitespace from Target before applying patch?
         */
        'Trim-Target-Whitespace'?: 'true' | 'false';
    };
    path?: never;
    query?: never;
    url: '/active/';
};

export type PatchActiveErrors = {
    /**
     * Bad Request; see response message for details.
     */
    400: _Error;
    /**
     * Does not exist
     */
    404: _Error;
    /**
     * Your path references a directory instead of a file; this request method is valid only for updating files.
     *
     */
    405: _Error;
};

export type PatchActiveError = PatchActiveErrors[keyof PatchActiveErrors];

export type PatchActiveResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type PostActiveData = {
    /**
     * Content you would like to append.
     */
    body: string;
    path?: never;
    query?: never;
    url: '/active/';
};

export type PostActiveErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Your path references a directory instead of a file; this request method is valid only for updating files.
     *
     */
    405: _Error;
};

export type PostActiveError = PostActiveErrors[keyof PostActiveErrors];

export type PostActiveResponses = {
    /**
     * Success
     */
    204: void;
};

export type PostActiveResponse = PostActiveResponses[keyof PostActiveResponses];

export type PutActiveData = {
    /**
     * Content of the file you would like to upload.
     */
    body: string;
    path?: never;
    query?: never;
    url: '/active/';
};

export type PutActiveErrors = {
    /**
     * Incoming file could not be processed.  Make sure you have specified a reasonable file name, and make sure you have set a reasonable 'Content-Type' header; if you are uploading a note, 'text/markdown' is likely the right choice.
     *
     */
    400: _Error;
    /**
     * Your path references a directory instead of a file; this request method is valid only for updating files.
     *
     */
    405: _Error;
};

export type PutActiveError = PutActiveErrors[keyof PutActiveErrors];

export type PutActiveResponses = {
    /**
     * Success
     */
    204: void;
};

export type PutActiveResponse = PutActiveResponses[keyof PutActiveResponses];

export type GetCommandsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/commands/';
};

export type GetCommandsResponses = {
    /**
     * A list of available commands.
     */
    200: {
        commands?: Array<{
            id?: string;
            name?: string;
        }>;
    };
};

export type GetCommandsResponse = GetCommandsResponses[keyof GetCommandsResponses];

export type PostCommandsByCommandIdData = {
    body?: never;
    path: {
        /**
         * The id of the command to execute
         */
        commandId: string;
    };
    query?: never;
    url: '/commands/{commandId}/';
};

export type PostCommandsByCommandIdErrors = {
    /**
     * The command you specified does not exist.
     */
    404: _Error;
};

export type PostCommandsByCommandIdError = PostCommandsByCommandIdErrors[keyof PostCommandsByCommandIdErrors];

export type PostCommandsByCommandIdResponses = {
    /**
     * Success
     */
    204: void;
};

export type PostCommandsByCommandIdResponse = PostCommandsByCommandIdResponses[keyof PostCommandsByCommandIdResponses];

export type PostOpenByFilenameData = {
    body?: never;
    path: {
        /**
         * Path to the file to return (relative to your vault root).
         *
         */
        filename: string;
    };
    query?: {
        /**
         * Open this as a new leaf?
         */
        newLeaf?: boolean;
    };
    url: '/open/{filename}';
};

export type PostOpenByFilenameResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type DeletePeriodicByPeriodData = {
    body?: never;
    path: {
        /**
         * The name of the period for which you would like to grab the current note.
         */
        period: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';
    };
    query?: never;
    url: '/periodic/{period}/';
};

export type DeletePeriodicByPeriodErrors = {
    /**
     * File does not exist.
     */
    404: _Error;
    /**
     * Your path references a directory instead of a file; this request method is valid only for updating files.
     *
     */
    405: _Error;
};

export type DeletePeriodicByPeriodError = DeletePeriodicByPeriodErrors[keyof DeletePeriodicByPeriodErrors];

export type DeletePeriodicByPeriodResponses = {
    /**
     * Success
     */
    204: void;
};

export type DeletePeriodicByPeriodResponse = DeletePeriodicByPeriodResponses[keyof DeletePeriodicByPeriodResponses];

export type GetPeriodicByPeriodData = {
    body?: never;
    path: {
        /**
         * The name of the period for which you would like to grab the current note.
         */
        period: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';
    };
    query?: never;
    url: '/periodic/{period}/';
};

export type GetPeriodicByPeriodErrors = {
    /**
     * File does not exist
     */
    404: unknown;
};

export type GetPeriodicByPeriodResponses = {
    /**
     * Success
     */
    200: NoteJson;
};

export type GetPeriodicByPeriodResponse = GetPeriodicByPeriodResponses[keyof GetPeriodicByPeriodResponses];

export type PatchPeriodicByPeriodData = {
    /**
     * Content you would like to insert.
     */
    body: string;
    headers: {
        /**
         * Patch operation to perform
         */
        Operation: 'append' | 'prepend' | 'replace';
        /**
         * Type of target to patch
         */
        'Target-Type': 'heading' | 'block' | 'frontmatter';
        /**
         * Delimiter to use for nested targets (i.e. Headings)
         */
        'Target-Delimiter'?: string;
        /**
         * Target to patch; this value can be URL-Encoded and *must*
         * be URL-Encoded if it includes non-ASCII characters.
         *
         */
        Target: string;
        /**
         * Trim whitespace from Target before applying patch?
         */
        'Trim-Target-Whitespace'?: 'true' | 'false';
    };
    path: {
        /**
         * The name of the period for which you would like to grab the current note.
         */
        period: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';
    };
    query?: never;
    url: '/periodic/{period}/';
};

export type PatchPeriodicByPeriodErrors = {
    /**
     * Bad Request; see response message for details.
     */
    400: _Error;
    /**
     * Does not exist
     */
    404: _Error;
    /**
     * Your path references a directory instead of a file; this request method is valid only for updating files.
     *
     */
    405: _Error;
};

export type PatchPeriodicByPeriodError = PatchPeriodicByPeriodErrors[keyof PatchPeriodicByPeriodErrors];

export type PatchPeriodicByPeriodResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type PostPeriodicByPeriodData = {
    /**
     * Content you would like to append.
     */
    body: string;
    path: {
        /**
         * The name of the period for which you would like to grab the current note.
         */
        period: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';
    };
    query?: never;
    url: '/periodic/{period}/';
};

export type PostPeriodicByPeriodErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Your path references a directory instead of a file; this request method is valid only for updating files.
     *
     */
    405: _Error;
};

export type PostPeriodicByPeriodError = PostPeriodicByPeriodErrors[keyof PostPeriodicByPeriodErrors];

export type PostPeriodicByPeriodResponses = {
    /**
     * Success
     */
    204: void;
};

export type PostPeriodicByPeriodResponse = PostPeriodicByPeriodResponses[keyof PostPeriodicByPeriodResponses];

export type PutPeriodicByPeriodData = {
    /**
     * Content of the file you would like to upload.
     */
    body: string;
    path: {
        /**
         * The name of the period for which you would like to grab the current note.
         */
        period: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';
    };
    query?: never;
    url: '/periodic/{period}/';
};

export type PutPeriodicByPeriodErrors = {
    /**
     * Incoming file could not be processed.  Make sure you have specified a reasonable file name, and make sure you have set a reasonable 'Content-Type' header; if you are uploading a note, 'text/markdown' is likely the right choice.
     *
     */
    400: _Error;
    /**
     * Your path references a directory instead of a file; this request method is valid only for updating files.
     *
     */
    405: _Error;
};

export type PutPeriodicByPeriodError = PutPeriodicByPeriodErrors[keyof PutPeriodicByPeriodErrors];

export type PutPeriodicByPeriodResponses = {
    /**
     * Success
     */
    204: void;
};

export type PutPeriodicByPeriodResponse = PutPeriodicByPeriodResponses[keyof PutPeriodicByPeriodResponses];

export type PostSearchData = {
    body: {
        [key: string]: unknown;
    };
    path?: never;
    query?: never;
    url: '/search/';
};

export type PostSearchErrors = {
    /**
     * Bad request.  Make sure you have specified an acceptable
     * Content-Type for your search query.
     *
     */
    400: _Error;
};

export type PostSearchError = PostSearchErrors[keyof PostSearchErrors];

export type PostSearchResponses = {
    /**
     * Success
     */
    200: Array<{
        /**
         * Path to the matching file
         */
        filename: string;
        result: string | number | Array<unknown> | {
            [key: string]: unknown;
        } | boolean;
    }>;
};

export type PostSearchResponse = PostSearchResponses[keyof PostSearchResponses];

export type PostSearchSimpleData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Your search query
         */
        query: string;
        /**
         * How much context to return around the matching string
         */
        contextLength?: number;
    };
    url: '/search/simple/';
};

export type PostSearchSimpleResponses = {
    /**
     * Success
     */
    200: Array<{
        /**
         * Path to the matching file
         */
        filename?: string;
        matches?: Array<{
            context: string;
            match: {
                end: number;
                start: number;
            };
        }>;
        score?: number;
    }>;
};

export type PostSearchSimpleResponse = PostSearchSimpleResponses[keyof PostSearchSimpleResponses];

export type GetVaultData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/vault/';
};

export type GetVaultErrors = {
    /**
     * Directory does not exist
     */
    404: _Error;
};

export type GetVaultError = GetVaultErrors[keyof GetVaultErrors];

export type GetVaultResponses = {
    /**
     * Success
     */
    200: {
        files?: Array<string>;
    };
};

export type GetVaultResponse = GetVaultResponses[keyof GetVaultResponses];

export type DeleteVaultByFilenameData = {
    body?: never;
    path: {
        /**
         * Path to the relevant file (relative to your vault root).
         *
         */
        filename: string;
    };
    query?: never;
    url: '/vault/{filename}';
};

export type DeleteVaultByFilenameErrors = {
    /**
     * File does not exist.
     */
    404: _Error;
    /**
     * Your path references a directory instead of a file; this request method is valid only for updating files.
     *
     */
    405: _Error;
};

export type DeleteVaultByFilenameError = DeleteVaultByFilenameErrors[keyof DeleteVaultByFilenameErrors];

export type DeleteVaultByFilenameResponses = {
    /**
     * Success
     */
    204: void;
};

export type DeleteVaultByFilenameResponse = DeleteVaultByFilenameResponses[keyof DeleteVaultByFilenameResponses];

export type GetVaultByFilenameData = {
    body?: never;
    path: {
        /**
         * Path to the relevant file (relative to your vault root).
         *
         */
        filename: string;
    };
    query?: never;
    url: '/vault/{filename}';
};

export type GetVaultByFilenameErrors = {
    /**
     * File does not exist
     */
    404: unknown;
};

export type GetVaultByFilenameResponses = {
    /**
     * Success
     */
    200: NoteJson;
};

export type GetVaultByFilenameResponse = GetVaultByFilenameResponses[keyof GetVaultByFilenameResponses];

export type PatchVaultByFilenameData = {
    /**
     * Content you would like to insert.
     */
    body: string;
    headers: {
        /**
         * Patch operation to perform
         */
        Operation: 'append' | 'prepend' | 'replace';
        /**
         * Type of target to patch
         */
        'Target-Type': 'heading' | 'block' | 'frontmatter';
        /**
         * Delimiter to use for nested targets (i.e. Headings)
         */
        'Target-Delimiter'?: string;
        /**
         * Target to patch; this value can be URL-Encoded and *must*
         * be URL-Encoded if it includes non-ASCII characters.
         *
         */
        Target: string;
        /**
         * Trim whitespace from Target before applying patch?
         */
        'Trim-Target-Whitespace'?: 'true' | 'false';
    };
    path: {
        /**
         * Path to the relevant file (relative to your vault root).
         *
         */
        filename: string;
    };
    query?: never;
    url: '/vault/{filename}';
};

export type PatchVaultByFilenameErrors = {
    /**
     * Bad Request; see response message for details.
     */
    400: _Error;
    /**
     * Does not exist
     */
    404: _Error;
    /**
     * Your path references a directory instead of a file; this request method is valid only for updating files.
     *
     */
    405: _Error;
};

export type PatchVaultByFilenameError = PatchVaultByFilenameErrors[keyof PatchVaultByFilenameErrors];

export type PatchVaultByFilenameResponses = {
    /**
     * Success
     */
    200: unknown;
};

export type PostVaultByFilenameData = {
    /**
     * Content you would like to append.
     */
    body: string;
    path: {
        /**
         * Path to the relevant file (relative to your vault root).
         *
         */
        filename: string;
    };
    query?: never;
    url: '/vault/{filename}';
};

export type PostVaultByFilenameErrors = {
    /**
     * Bad Request
     */
    400: _Error;
    /**
     * Your path references a directory instead of a file; this request method is valid only for updating files.
     *
     */
    405: _Error;
};

export type PostVaultByFilenameError = PostVaultByFilenameErrors[keyof PostVaultByFilenameErrors];

export type PostVaultByFilenameResponses = {
    /**
     * Success
     */
    204: void;
};

export type PostVaultByFilenameResponse = PostVaultByFilenameResponses[keyof PostVaultByFilenameResponses];

export type PutVaultByFilenameData = {
    /**
     * Content of the file you would like to upload.
     */
    body: string;
    path: {
        /**
         * Path to the relevant file (relative to your vault root).
         *
         */
        filename: string;
    };
    query?: never;
    url: '/vault/{filename}';
};

export type PutVaultByFilenameErrors = {
    /**
     * Incoming file could not be processed.  Make sure you have specified a reasonable file name, and make sure you have set a reasonable 'Content-Type' header; if you are uploading a note, 'text/markdown' is likely the right choice.
     *
     */
    400: _Error;
    /**
     * Your path references a directory instead of a file; this request method is valid only for updating files.
     *
     */
    405: _Error;
};

export type PutVaultByFilenameError = PutVaultByFilenameErrors[keyof PutVaultByFilenameErrors];

export type PutVaultByFilenameResponses = {
    /**
     * Success
     */
    204: void;
};

export type PutVaultByFilenameResponse = PutVaultByFilenameResponses[keyof PutVaultByFilenameResponses];

export type GetVaultByPathToDirectoryData = {
    body?: never;
    path: {
        /**
         * Path to list files from (relative to your vault root).  Note that empty directories will not be returned.
         *
         * Note: this particular interactive tool requires that you provide an argument for this field, but the API itself will allow you to list the root folder of your vault. If you would like to try listing content in the root of your vault using this interactive tool, use the above "List files that exist in the root of your vault" form above.
         *
         */
        pathToDirectory: string;
    };
    query?: never;
    url: '/vault/{pathToDirectory}/';
};

export type GetVaultByPathToDirectoryErrors = {
    /**
     * Directory does not exist
     */
    404: _Error;
};

export type GetVaultByPathToDirectoryError = GetVaultByPathToDirectoryErrors[keyof GetVaultByPathToDirectoryErrors];

export type GetVaultByPathToDirectoryResponses = {
    /**
     * Success
     */
    200: {
        files?: Array<string>;
    };
};

export type GetVaultByPathToDirectoryResponse = GetVaultByPathToDirectoryResponses[keyof GetVaultByPathToDirectoryResponses];

export type ClientOptions = {
    baseUrl: 'https://{host}:{port}' | 'http://{host}:{port}' | (string & {});
};