name: Blog Grammar Check

on:
  pull_request:
    branches:
      - main
    paths:
      - "apps/web/content/articles/**"

jobs:
  grammar-check:
    if: startsWith(github.head_ref, 'blog/')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Get changed files
        id: changed-files
        run: |
          FILES=$(git diff --name-only origin/${{ github.base_ref }}...HEAD -- 'apps/web/content/articles/*.mdx' | tr '\n' ' ')
          echo "files=$FILES" >> $GITHUB_OUTPUT
          if [ -z "$FILES" ]; then
            echo "has_files=false" >> $GITHUB_OUTPUT
          else
            echo "has_files=true" >> $GITHUB_OUTPUT
          fi

      - name: Install dependencies
        if: steps.changed-files.outputs.has_files == 'true'
        run: npm install ai @ai-sdk/anthropic zod

      - name: Run grammar check
        if: steps.changed-files.outputs.has_files == 'true'
        id: grammar-check
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          CHANGED_FILES: ${{ steps.changed-files.outputs.files }}
        run: |
          node .github/scripts/grammar-check.mjs

      - name: Extract article info
        if: steps.changed-files.outputs.has_files == 'true'
        id: article-info
        run: |
          FILE=$(echo "${{ steps.changed-files.outputs.files }}" | awk '{print $1}')
          if [ -f "$FILE" ]; then
            # Extract display_title or fall back to meta_title (handles quoted YAML values)
            # Use jq to properly escape for JSON
            RAW_TITLE=$(grep -m1 "^display_title:" "$FILE" | sed 's/display_title:[[:space:]]*"\(.*\)"/\1/' || echo "")
            if [ -z "$RAW_TITLE" ]; then
              RAW_TITLE=$(grep -m1 "^meta_title:" "$FILE" | sed 's/meta_title:[[:space:]]*"\(.*\)"/\1/' || echo "Untitled")
            fi
            RAW_AUTHOR=$(grep -m1 "^author:" "$FILE" | sed 's/author:[[:space:]]*"\(.*\)"/\1/' || echo "Unknown")
            RAW_DATE=$(grep -m1 "^date:" "$FILE" | sed 's/date:[[:space:]]*"\(.*\)"/\1/' || echo "")

            # Escape for JSON (remove surrounding quotes that jq adds)
            TITLE=$(echo "$RAW_TITLE" | jq -Rs . | sed 's/^"//;s/"$//')
            AUTHOR=$(echo "$RAW_AUTHOR" | jq -Rs . | sed 's/^"//;s/"$//')
            DATE=$(echo "$RAW_DATE" | jq -Rs . | sed 's/^"//;s/"$//')
          else
            TITLE="Untitled"
            AUTHOR="Unknown"
            DATE=""
          fi
          echo "title=$TITLE" >> $GITHUB_OUTPUT
          echo "author=$AUTHOR" >> $GITHUB_OUTPUT
          echo "date=$DATE" >> $GITHUB_OUTPUT

          # Determine if this is a new article or edit (edit branches have timestamp suffix)
          BRANCH="${{ github.head_ref }}"
          if [[ "$BRANCH" =~ -[0-9]+$ ]]; then
            echo "is_edit=true" >> $GITHUB_OUTPUT
          else
            echo "is_edit=false" >> $GITHUB_OUTPUT
          fi

          # Map GitHub username to Slack user ID
          GH_USER="${{ github.event.pull_request.user.login }}"
          case "$GH_USER" in
            "yujonglee") SLACK_USER="<@U0628P6TAPL>" ;;
            "ComputelessComputer") SLACK_USER="<@U08PVBSGL31>" ;;
            "harshikaalagh-netizen") SLACK_USER="<@U0976J9CAKF>" ;;
            *) SLACK_USER="$GH_USER" ;;
          esac
          echo "slack_user=$SLACK_USER" >> $GITHUB_OUTPUT

      - name: Post PR comment
        if: steps.changed-files.outputs.has_files == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const comment = fs.readFileSync('grammar-check-results.md', 'utf8');

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c =>
              c.user.type === 'Bot' &&
              c.body.includes('<!-- grammar-check-bot -->')
            );

            const body = `<!-- grammar-check-bot -->\n${comment}`;

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: Check ready_for_review status
        if: steps.changed-files.outputs.has_files == 'true'
        id: review-status
        run: |
          FILE=$(echo "${{ steps.changed-files.outputs.files }}" | awk '{print $1}')
          if [ -f "$FILE" ]; then
            READY_FOR_REVIEW=$(grep -m1 "^ready_for_review:" "$FILE" | sed 's/ready_for_review:[[:space:]]*//' || echo "false")
            echo "ready_for_review=$READY_FOR_REVIEW" >> $GITHUB_OUTPUT
          else
            echo "ready_for_review=false" >> $GITHUB_OUTPUT
          fi

      - name: Notify Slack
        if: steps.changed-files.outputs.has_files == 'true'
        uses: slackapi/slack-github-action@v2.0.0
        with:
          method: chat.postMessage
          token: ${{ secrets.SLACK_BOT_TOKEN }}
          payload: |
            {
              "channel": "${{ secrets.SLACK_BLOG_CHANNEL_ID }}",
              "text": "${{ steps.review-status.outputs.ready_for_review == 'true' && format('Article submitted for review: {0}', steps.article-info.outputs.title) || (steps.article-info.outputs.is_edit == 'true' && format('{0} made changes to {1}', steps.article-info.outputs.slack_user, steps.article-info.outputs.title) || format('{0} is ready to publish: {1}', steps.article-info.outputs.slack_user, steps.article-info.outputs.title)) }}",
              "attachments": [
                {
                  "color": "${{ steps.review-status.outputs.ready_for_review == 'true' && '#3b82f6' || '#2eb886' }}",
                  "blocks": [
                    {
                      "type": "section",
                      "text": {
                        "type": "mrkdwn",
                        "text": "${{ steps.review-status.outputs.ready_for_review == 'true' && format('üëÄ *Article submitted for review*\n<@U08PVBSGL31> please review\n\n>*{0}*', steps.article-info.outputs.title) || (steps.article-info.outputs.is_edit == 'true' && format('‚úèÔ∏è {0} made changes to *{1}*', steps.article-info.outputs.slack_user, steps.article-info.outputs.title) || format('üöÄ {0} is ready to publish a new article: *{1}*', steps.article-info.outputs.slack_user, steps.article-info.outputs.title)) }}"
                      }
                    },
                    {
                      "type": "context",
                      "elements": [
                        {
                          "type": "mrkdwn",
                          "text": "üë§ ${{ steps.article-info.outputs.author }}${{ steps.article-info.outputs.date != '' && format(' ‚Ä¢ üìÖ {0}', steps.article-info.outputs.date) || '' }}"
                        }
                      ]
                    },
                    {
                      "type": "actions",
                      "elements": [
                        {
                          "type": "button",
                          "text": {
                            "type": "plain_text",
                            "text": "View PR",
                            "emoji": true
                          },
                          "url": "${{ github.event.pull_request.html_url }}",
                          "style": "primary"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
