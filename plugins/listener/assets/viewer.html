<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Viewer</title>
  <script src="https://cdn.twind.style" crossorigin></script>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@tanstack/react-query@4/build/umd/index.production.js"></script>
</head>
<body class="bg-gradient-to-br from-gray-900 via-gray-800 to-gray-900 text-gray-100 h-screen overflow-hidden">
  <div id="app"></div>
  <div id="tooltip" style="display: none; position: absolute; background: #1f2937; color: white; padding: 6px 10px; border-radius: 6px; font-size: 12px; font-family: monospace; z-index: 9999; border: 1px solid #374151; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);"></div>

  <script type="module">
    import htm from 'https://esm.sh/htm';
    import { computePosition, flip, shift, offset } from 'https://cdn.jsdelivr.net/npm/@floating-ui/dom@1.7.3/+esm';
    
    const FILE_OPTIONS = [
      "council_011320_2022003V",
      "f7952672-5d18-4f75-8aa0-74ab8b02dac3",
      "14b0f420-81e0-4104-b16a-585f1b1b0b56",
      "7a6ad933-4bad-48d1-96c2-c4346052b3cd"
    ];
    
    const html = htm.bind(React.createElement);
    const { useState, useEffect, useRef } = React;
    const { QueryClient, QueryClientProvider, useQuery } = ReactQuery;
    
    const queryClient = new QueryClient({
      defaultOptions: {
        queries: {
          refetchOnWindowFocus: false,
          retry: 1,
        },
      },
    });

    const App = () => {
      const [currentIndex, setCurrentIndex] = useState(0);
      const [selectedFile, setSelectedFile] = useState(FILE_OPTIONS[3]);
      const [stepSize, setStepSize] = useState(1);
      const contentRef = useRef(null);
      const tooltipRef = useRef(document.getElementById('tooltip'));

      const { data = [], isLoading, isError, error } = useQuery({
        queryKey: ['diffData', selectedFile],
        queryFn: async () => {
          const response = await fetch(`./diff/${selectedFile}.json`);
          if (!response.ok) {
            throw new Error('Failed to load file');
          }
          return response.json();
        },
        onSuccess: () => {
          setCurrentIndex(0);
        },
      });

      useEffect(() => {
        const handleKeydown = (e) => {
          if (e.key === 'ArrowLeft') {
            setCurrentIndex(prev => Math.max(0, prev - stepSize));
          } else if (e.key === 'ArrowRight') {
            setCurrentIndex(prev => Math.min(data.length - 1, prev + stepSize));
          }
        };
        
        window.addEventListener('keydown', handleKeydown);
        return () => window.removeEventListener('keydown', handleKeydown);
      }, [currentIndex, data.length, stepSize]);

      useEffect(() => {
        if (contentRef.current) {
          contentRef.current.scrollTop = contentRef.current.scrollHeight;
        }
      }, [currentIndex]);

      const showTooltip = async (e, word) => {
        const tooltip = tooltipRef.current;
        const target = e.currentTarget;
        
        tooltip.innerHTML = `<div>${word.start.toFixed(3)}s ~ ${word.end.toFixed(3)}s</div>`;
        
        tooltip.style.display = 'block';
        
        const { x, y } = await computePosition(target, tooltip, {
          placement: 'top',
          middleware: [offset(6), flip(), shift({ padding: 5 })]
        });
        
        Object.assign(tooltip.style, {left: `${x}px`, top: `${y}px`});
      };

      const hideTooltip = () => {
        tooltipRef.current.style.display = 'none';
      };
      
      const buildSpeakerSegments = () => {
        const segments = [];
        const activeSegments = new Map(); // speaker -> segment
        
        // Process all frames up to and including current
        for (let frameIdx = 0; frameIdx <= currentIndex && frameIdx < data.length; frameIdx++) {
          const frame = data[frameIdx];
          const isCurrent = frameIdx === currentIndex;
          
          // Process final words from all frames up to current, and partial words only from current
          const wordsToProcess = [];
          
          // Add final words
          if (frame.final_words) {
            Object.entries(frame.final_words).forEach(([channelKey, words]) => {
              words.forEach(word => {
                wordsToProcess.push({
                  ...word,
                  type: 'final',
                  frameIndex: frameIdx,
                  channelKey
                });
              });
            });
          }
          
          // Add partial words only from current frame
          if (isCurrent && frame.partial_words) {
            Object.entries(frame.partial_words).forEach(([channelKey, words]) => {
              words.forEach(word => {
                wordsToProcess.push({
                  ...word,
                  type: 'partial',
                  frameIndex: frameIdx,
                  channelKey
                });
              });
            });
          }
          
          // Sort words by start time
          wordsToProcess.sort((a, b) => a.start - b.start);
          
          // Process each word
          wordsToProcess.forEach(word => {
            const speaker = word.speaker ?? 'unknown';
            
            // Check if this word overlaps with any existing active segment for this speaker
            let targetSegment = activeSegments.get(speaker);
            let shouldMergeWithExisting = false;
            
            if (targetSegment) {
              // Check if there's a time gap (more than 1 second) between last word and this word
              const lastWord = targetSegment.words[targetSegment.words.length - 1];
              const timeGap = word.start - lastWord.end;
              
              if (timeGap > 1.0) {
                // Too much gap, create a new segment
                targetSegment = null;
              }
            }
            
            // If we need a new segment
            if (!targetSegment) {
              // Check if this word's start time overlaps with any other active segment
              
              for (const [otherSpeaker, otherSegment] of activeSegments) {
                if (otherSpeaker !== speaker && otherSegment.words.length > 0) {
                  const otherLastWord = otherSegment.words[otherSegment.words.length - 1];
                  
                  // If this word starts before the other segment's last word ends
                  if (word.start < otherLastWord.end) {
                    // Check if we have an earlier segment from this speaker that could be extended
                    for (let i = segments.length - 1; i >= 0; i--) {
                      if (segments[i].speaker === speaker) {
                        const segLastWord = segments[i].words[segments[i].words.length - 1];
                        // If the gap is small enough, merge with the existing segment
                        if (word.start - segLastWord.end < 0.5) {
                          segments[i].words.push(word);
                          shouldMergeWithExisting = true;
                          // Update the active segment reference
                          activeSegments.set(speaker, segments[i]);
                          break;
                        }
                      }
                    }
                    break;
                  }
                }
              }
              
              if (!shouldMergeWithExisting) {
                // Create new segment
                targetSegment = {
                  speaker: speaker,
                  words: []
                };
                segments.push(targetSegment);
                activeSegments.set(speaker, targetSegment);
                
                // Deactivate other speakers if this word comes after their last word
                for (const [otherSpeaker, otherSegment] of activeSegments) {
                  if (otherSpeaker !== speaker && otherSegment.words.length > 0) {
                    const otherLastWord = otherSegment.words[otherSegment.words.length - 1];
                    if (word.start >= otherLastWord.end) {
                      activeSegments.delete(otherSpeaker);
                    }
                  }
                }
              }
            }
            
            // Add word to the target segment
            if (targetSegment && !shouldMergeWithExisting) {
              targetSegment.words.push(word);
            }
          });
        }
        
        return segments;
      };

      const getSpeakerColor = (speaker) => {
        const colors = [
          'text-blue-400',
          'text-green-400',
          'text-yellow-400',
          'text-purple-400',
          'text-pink-400',
          'text-indigo-400',
          'text-orange-400',
          'text-teal-400'
        ];
        
        if (speaker === 'unknown') return 'text-gray-400';
        return colors[speaker % colors.length];
      };

      const renderContent = () => {
        if (isLoading) {
          return html`<span class="text-gray-500 italic">Loading...</span>`;
        }
        
        if (isError) {
          return html`<span class="text-red-400 italic">Error: ${error.message}</span>`;
        }
        
        const segments = buildSpeakerSegments();
        
        if (segments.length === 0) {
          return html`<span class="text-gray-500 italic">No content to display</span>`;
        }
        
        return html`
          <div class="space-y-3">
            ${segments.map((segment, segIndex) => html`
              <div key=${segIndex} class="flex gap-3">
                <div class="flex-shrink-0 w-12 text-right">
                  <span class="${getSpeakerColor(segment.speaker)} font-bold">
                    ${segment.speaker === 'unknown' ? '?' : segment.speaker}:
                  </span>
                </div>
                <div class="flex-1 leading-relaxed">
                  ${segment.words.map((word, wordIndex) => html`
                    <span 
                      key=${wordIndex} 
                      class="${word.type === 'final' ? 'text-rose-400' : 'text-emerald-400'} font-medium cursor-help hover:underline"
                      onMouseEnter=${(e) => showTooltip(e, word)}
                      onMouseLeave=${hideTooltip}
                    >
                      ${wordIndex > 0 ? ' ' : ''}${word.word}
                    </span>
                  `)}
                </div>
              </div>
            `)}
          </div>
        `;
      };

      return html`
        <div class="h-screen flex flex-col p-6">
          <div class="bg-gray-800/50 backdrop-blur-sm rounded-xl border border-gray-700/50 p-4 mb-4">
            <div class="flex items-center justify-between flex-wrap gap-4">
              <div class="flex items-center gap-3">
                <label class="text-sm text-gray-400 font-medium">File:</label>
                <select 
                  value=${selectedFile}
                  onChange=${e => setSelectedFile(e.target.value)}
                  class="bg-gray-900/50 border border-gray-600 rounded-lg px-4 py-2 text-gray-100 hover:bg-gray-900/70 transition-colors focus:outline-none focus:ring-2 focus:ring-blue-500/50"
                >
                  ${FILE_OPTIONS.map(file => html`
                    <option key=${file} value=${file}>${file}</option>
                  `)}
                </select>
              </div>

              <div class="flex items-center gap-3">
                <button 
                  onClick=${() => setCurrentIndex(Math.max(0, currentIndex - stepSize))}
                  disabled=${currentIndex === 0 || isLoading}
                  class="bg-gray-900/50 hover:bg-gray-900/70 px-4 py-2 rounded-lg border border-gray-600 transition-all ${(currentIndex === 0 || isLoading) ? 'opacity-40 cursor-not-allowed' : 'hover:border-blue-500/50'}"
                  title="Previous (← arrow key)"
                >
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
                  </svg>
                </button>
                
                <div class="bg-gray-900/50 px-4 py-2 rounded-lg border border-gray-600 min-w-[100px] text-center">
                  ${isLoading ? html`
                    <span class="text-sm text-gray-400">Loading...</span>
                  ` : html`
                    <span class="text-sm font-semibold text-blue-400">
                      ${data.length > 0 ? `${currentIndex + 1}` : '0'}
                    </span>
                    <span class="text-sm text-gray-400"> / ${data.length}</span>
                  `}
                </div>
                
                <button 
                  onClick=${() => setCurrentIndex(Math.min(data.length - 1, currentIndex + stepSize))}
                  disabled=${currentIndex >= data.length - 1 || isLoading}
                  class="bg-gray-900/50 hover:bg-gray-900/70 px-4 py-2 rounded-lg border border-gray-600 transition-all ${(currentIndex >= data.length - 1 || isLoading) ? 'opacity-40 cursor-not-allowed' : 'hover:border-blue-500/50'}"
                  title="Next (→ arrow key)"
                >
                  <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />
                  </svg>
                </button>

                <div class="flex items-center gap-2 ml-2 px-3 py-1 bg-gray-900/50 rounded-lg border border-gray-600">
                  <label class="text-xs text-gray-400">Step:</label>
                  <select 
                    value=${stepSize}
                    onChange=${e => setStepSize(Number(e.target.value))}
                    class="bg-transparent text-sm text-gray-100 focus:outline-none"
                  >
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="4">4</option>
                    <option value="8">8</option>
                  </select>
                </div>
              </div>

              <div class="flex items-center gap-4 text-sm">
                <div class="flex items-center gap-2">
                  <div class="w-3 h-3 bg-rose-400 rounded-full"></div>
                  <span class="text-gray-300">Final</span>
                </div>
                <div class="flex items-center gap-2">
                  <div class="w-3 h-3 bg-emerald-400 rounded-full"></div>
                  <span class="text-gray-300">Partial</span>
                </div>
              </div>
            </div>
          </div>
          
          <div class="flex-1 bg-gray-800/30 backdrop-blur-sm rounded-xl border border-gray-700/50 p-8 overflow-hidden flex flex-col">
            <div ref=${contentRef} class="flex-1 overflow-y-auto scroll-smooth">
              <div class="font-mono text-lg text-gray-100">
                ${renderContent()}
              </div>
            </div>
          </div>

          <div class="mt-3 text-center text-xs text-gray-500">
            ${isLoading ? 'Loading data...' : 'Use arrow keys (← →) for navigation • Step size controls how many items to skip • Hover over words for timestamps'}
          </div>
        </div>
      `;
    };

    const Root = () => {
      return html`
        <${QueryClientProvider} client=${queryClient}>
          <${App} />
        <//>
      `;
    };

    ReactDOM.render(html`<${Root} />`, document.getElementById('app'));
  </script>
</body>
</html>
