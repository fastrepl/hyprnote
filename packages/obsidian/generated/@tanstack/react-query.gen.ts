// This file is auto-generated by @hey-api/openapi-ts

import { type DefaultError, queryOptions, type UseMutationOptions } from '@tanstack/react-query';

import { client } from '../client.gen';
import { deleteActive, deletePeriodicByPeriod, deletePeriodicByPeriodByYearByMonthByDay, deleteVaultByFilename, get, getActive, getCommands, getObsidianLocalRestApiCrt, getOpenapiYaml, getPeriodicByPeriod, getPeriodicByPeriodByYearByMonthByDay, getVault, getVaultByFilename, getVaultByPathToDirectory, type Options, patchActive, patchPeriodicByPeriod, patchPeriodicByPeriodByYearByMonthByDay, patchVaultByFilename, postActive, postCommandsByCommandId, postOpenByFilename, postPeriodicByPeriod, postPeriodicByPeriodByYearByMonthByDay, postSearch, postSearchSimple, postVaultByFilename, putActive, putPeriodicByPeriod, putPeriodicByPeriodByYearByMonthByDay, putVaultByFilename } from '../sdk.gen';
import type { DeleteActiveData, DeleteActiveError, DeleteActiveResponse, DeletePeriodicByPeriodByYearByMonthByDayData, DeletePeriodicByPeriodByYearByMonthByDayError, DeletePeriodicByPeriodByYearByMonthByDayResponse, DeletePeriodicByPeriodData, DeletePeriodicByPeriodError, DeletePeriodicByPeriodResponse, DeleteVaultByFilenameData, DeleteVaultByFilenameError, DeleteVaultByFilenameResponse, GetActiveData, GetActiveResponse, GetCommandsData, GetCommandsResponse, GetData, GetObsidianLocalRestApiCrtData, GetOpenapiYamlData, GetPeriodicByPeriodByYearByMonthByDayData, GetPeriodicByPeriodByYearByMonthByDayResponse, GetPeriodicByPeriodData, GetPeriodicByPeriodResponse, GetResponse, GetVaultByFilenameData, GetVaultByFilenameResponse, GetVaultByPathToDirectoryData, GetVaultByPathToDirectoryError, GetVaultByPathToDirectoryResponse, GetVaultData, GetVaultError, GetVaultResponse, PatchActiveData, PatchActiveError, PatchPeriodicByPeriodByYearByMonthByDayData, PatchPeriodicByPeriodByYearByMonthByDayError, PatchPeriodicByPeriodData, PatchPeriodicByPeriodError, PatchVaultByFilenameData, PatchVaultByFilenameError, PostActiveData, PostActiveError, PostActiveResponse, PostCommandsByCommandIdData, PostCommandsByCommandIdError, PostCommandsByCommandIdResponse, PostOpenByFilenameData, PostPeriodicByPeriodByYearByMonthByDayData, PostPeriodicByPeriodByYearByMonthByDayError, PostPeriodicByPeriodByYearByMonthByDayResponse, PostPeriodicByPeriodData, PostPeriodicByPeriodError, PostPeriodicByPeriodResponse, PostSearchData, PostSearchError, PostSearchResponse, PostSearchSimpleData, PostSearchSimpleResponse, PostVaultByFilenameData, PostVaultByFilenameError, PostVaultByFilenameResponse, PutActiveData, PutActiveError, PutActiveResponse, PutPeriodicByPeriodByYearByMonthByDayData, PutPeriodicByPeriodByYearByMonthByDayError, PutPeriodicByPeriodByYearByMonthByDayResponse, PutPeriodicByPeriodData, PutPeriodicByPeriodError, PutPeriodicByPeriodResponse, PutVaultByFilenameData, PutVaultByFilenameError, PutVaultByFilenameResponse } from '../types.gen';

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseUrl' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
        tags?: ReadonlyArray<string>;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean, tags?: ReadonlyArray<string>): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseUrl: options?.baseUrl || (options?.client ?? client).getConfig().baseUrl } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (tags) {
        params.tags = tags;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [params];
};

export const getQueryKey = (options?: Options<GetData>) => createQueryKey('get', options);

/**
 * Returns basic details about the server.
 *
 *
 * Returns basic details about the server as well as your authentication status.
 *
 * This is the only API request that does *not* require authentication.
 *
 */
export const getOptions = (options?: Options<GetData>) => queryOptions<GetResponse, DefaultError, GetResponse, ReturnType<typeof getQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await get({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getQueryKey(options)
});

/**
 * Deletes the currently-active file in Obsidian.
 *
 */
export const deleteActiveMutation = (options?: Partial<Options<DeleteActiveData>>): UseMutationOptions<DeleteActiveResponse, DeleteActiveError, Options<DeleteActiveData>> => {
    const mutationOptions: UseMutationOptions<DeleteActiveResponse, DeleteActiveError, Options<DeleteActiveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteActive({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getActiveQueryKey = (options?: Options<GetActiveData>) => createQueryKey('getActive', options);

/**
 * Return the content of the active file open in Obsidian.
 *
 *
 * Returns the content of the currently active file in Obsidian.
 *
 * If you specify the header `Accept: application/vnd.olrapi.note+json`, will return a JSON representation of your note including parsed tag and frontmatter data as well as filesystem metadata.  See "responses" below for details.
 *
 */
export const getActiveOptions = (options?: Options<GetActiveData>) => queryOptions<GetActiveResponse, DefaultError, GetActiveResponse, ReturnType<typeof getActiveQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getActive({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getActiveQueryKey(options)
});

/**
 * Partially update content in the currently open note.
 *
 *
 * Inserts content into the currently-open note relative to a heading, block refeerence, or frontmatter field within that document.
 *
 * Allows you to modify the content relative to a heading, block reference, or frontmatter field in your document.
 *
 * Note that this API was changed in Version 3.0 of this extension and the earlier PATCH API is now deprecated. Requests made using the previous version of this API will continue to work until Version 4.0 is released.  See https://github.com/coddingtonbear/obsidian-local-rest-api/wiki/Changes-to-PATCH-requests-between-versions-2.0-and-3.0 for more details and migration instructions.
 *
 * # Examples
 *
 * All of the below examples assume you have a document that looks like
 * this:
 *
 * ```markdown
 * ---
 * alpha: 1
 * beta: test
 * delta:
 * zeta: 1
 * yotta: 1
 * gamma:
 * - one
 * - two
 * ---
 *
 * # Heading 1
 *
 * This is the content for heading one
 *
 * Also references some [[#^484ef2]]
 *
 * ## Subheading 1:1
 * Content for Subheading 1:1
 *
 * ### Subsubheading 1:1:1
 *
 * ### Subsubheading 1:1:2
 *
 * Testing how block references work for a table.[[#^2c7cfa]]
 * Some content for Subsubheading 1:1:2
 *
 * More random text.
 *
 * ^2d9b4a
 *
 * ## Subheading 1:2
 *
 * Content for Subheading 1:2.
 *
 * some content with a block reference ^484ef2
 *
 * ## Subheading 1:3
 * | City         | Population |
 * | ------------ | ---------- |
 * | Seattle, WA  | 8          |
 * | Portland, OR | 4          |
 *
 * ^2c7cfa
 * ```
 *
 * ## Append Content Below a Heading
 *
 * If you wanted to append the content "Hello" below "Subheading 1:1:1" under "Heading 1",
 * you could send a request with the following headers:
 *
 * - `Operation`: `append`
 * - `Target-Type`: `heading`
 * - `Target`: `Heading 1::Subheading 1:1:1`
 * - with the request body: `Hello`
 *
 * The above would work just fine for `prepend` or `replace`, too, of course,
 * but with different results.
 *
 * ## Append Content to a Block Reference
 *
 * If you wanted to append the content "Hello" below the block referenced by
 * "2d9b4a" above ("More random text."), you could send the following headers:
 *
 * - `Operation`: `append`
 * - `Target-Type`: `block`
 * - `Target`: `2d9b4a`
 * - with the request body: `Hello`
 *
 * The above would work just fine for `prepend` or `replace`, too, of course,
 * but with different results.
 *
 * ## Add a Row to a Table Referenced by a Block Reference
 *
 * If you wanted to add a new city ("Chicago, IL") and population ("16") pair to the table above
 * referenced by the block reference `2c7cfa`, you could send the following
 * headers:
 *
 * - `Operation`: `append`
 * - `TargetType`: `block`
 * - `Target`: `2c7cfa`
 * - `Content-Type`: `application/json`
 * - with the request body: `[["Chicago, IL", "16"]]`
 *
 * The use of a `Content-Type` of `application/json` allows the API
 * to infer that member of your array represents rows and columns of your
 * to append to the referenced table.  You can of course just use a
 * `Content-Type` of `text/markdown`, but in such a case you'll have to
 * format your table row manually instead of letting the library figure
 * it out for you.
 *
 * You also have the option of using `prepend` (in which case, your new
 * row would be the first -- right below the table heading) or `replace` (in which
 * case all rows except the table heading would be replaced by the new row(s)
 * you supplied).
 *
 * ## Setting a Frontmatter Field
 *
 * If you wanted to set the frontmatter field `alpha` to `2`, you could
 * send the following headers:
 *
 * - `Operation`: `replace`
 * - `TargetType`: `frontmatter`
 * - `Target`: `beep`
 * - with the request body `2`
 *
 * If you're setting a frontmatter field that might not already exist
 * you may want to use the `Create-Target-If-Missing` header so the
 * new frontmatter field is created and set to your specified value
 * if it doesn't already exist.
 *
 * You may find using a `Content-Type` of `application/json` to be
 * particularly useful in the case of frontmatter since frontmatter
 * fields' values are JSON data, and the API can be smarter about
 * interpreting yoru `prepend` or `append` requests if you specify
 * your data as JSON (particularly when appending, for example,
 * list items).
 *
 */
export const patchActiveMutation = (options?: Partial<Options<PatchActiveData>>): UseMutationOptions<unknown, PatchActiveError, Options<PatchActiveData>> => {
    const mutationOptions: UseMutationOptions<unknown, PatchActiveError, Options<PatchActiveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchActive({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Append content to the active file open in Obsidian.
 *
 *
 * Appends content to the end of the currently-open note.
 *
 * If you would like to insert text relative to a particular heading instead of appending to the end of the file, see 'patch'.
 *
 */
export const postActiveMutation = (options?: Partial<Options<PostActiveData>>): UseMutationOptions<PostActiveResponse, PostActiveError, Options<PostActiveData>> => {
    const mutationOptions: UseMutationOptions<PostActiveResponse, PostActiveError, Options<PostActiveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postActive({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update the content of the active file open in Obsidian.
 *
 */
export const putActiveMutation = (options?: Partial<Options<PutActiveData>>): UseMutationOptions<PutActiveResponse, PutActiveError, Options<PutActiveData>> => {
    const mutationOptions: UseMutationOptions<PutActiveResponse, PutActiveError, Options<PutActiveData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await putActive({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCommandsQueryKey = (options?: Options<GetCommandsData>) => createQueryKey('getCommands', options);

/**
 * Get a list of available commands.
 *
 */
export const getCommandsOptions = (options?: Options<GetCommandsData>) => queryOptions<GetCommandsResponse, DefaultError, GetCommandsResponse, ReturnType<typeof getCommandsQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getCommands({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getCommandsQueryKey(options)
});

/**
 * Execute a command.
 *
 */
export const postCommandsByCommandIdMutation = (options?: Partial<Options<PostCommandsByCommandIdData>>): UseMutationOptions<PostCommandsByCommandIdResponse, PostCommandsByCommandIdError, Options<PostCommandsByCommandIdData>> => {
    const mutationOptions: UseMutationOptions<PostCommandsByCommandIdResponse, PostCommandsByCommandIdError, Options<PostCommandsByCommandIdData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postCommandsByCommandId({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getObsidianLocalRestApiCrtQueryKey = (options?: Options<GetObsidianLocalRestApiCrtData>) => createQueryKey('getObsidianLocalRestApiCrt', options);

/**
 * Returns the certificate in use by this API.
 *
 */
export const getObsidianLocalRestApiCrtOptions = (options?: Options<GetObsidianLocalRestApiCrtData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getObsidianLocalRestApiCrtQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getObsidianLocalRestApiCrt({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getObsidianLocalRestApiCrtQueryKey(options)
});

/**
 * Open the specified document in the Obsidian user interface.
 *
 *
 * Note: Obsidian will create a new document at the path you have
 * specified if such a document did not already exist.
 *
 */
export const postOpenByFilenameMutation = (options?: Partial<Options<PostOpenByFilenameData>>): UseMutationOptions<unknown, DefaultError, Options<PostOpenByFilenameData>> => {
    const mutationOptions: UseMutationOptions<unknown, DefaultError, Options<PostOpenByFilenameData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postOpenByFilename({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getOpenapiYamlQueryKey = (options?: Options<GetOpenapiYamlData>) => createQueryKey('getOpenapiYaml', options);

/**
 * Returns OpenAPI YAML document describing the capabilities of this API.
 *
 */
export const getOpenapiYamlOptions = (options?: Options<GetOpenapiYamlData>) => queryOptions<unknown, DefaultError, unknown, ReturnType<typeof getOpenapiYamlQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getOpenapiYaml({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getOpenapiYamlQueryKey(options)
});

/**
 * Delete the current periodic note for the specified period.
 *
 */
export const deletePeriodicByPeriodMutation = (options?: Partial<Options<DeletePeriodicByPeriodData>>): UseMutationOptions<DeletePeriodicByPeriodResponse, DeletePeriodicByPeriodError, Options<DeletePeriodicByPeriodData>> => {
    const mutationOptions: UseMutationOptions<DeletePeriodicByPeriodResponse, DeletePeriodicByPeriodError, Options<DeletePeriodicByPeriodData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePeriodicByPeriod({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPeriodicByPeriodQueryKey = (options: Options<GetPeriodicByPeriodData>) => createQueryKey('getPeriodicByPeriod', options);

/**
 * Get current periodic note for the specified period.
 *
 */
export const getPeriodicByPeriodOptions = (options: Options<GetPeriodicByPeriodData>) => queryOptions<GetPeriodicByPeriodResponse, DefaultError, GetPeriodicByPeriodResponse, ReturnType<typeof getPeriodicByPeriodQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPeriodicByPeriod({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPeriodicByPeriodQueryKey(options)
});

/**
 * Partially update content in the current periodic note for the specified period.
 *
 *
 * Inserts content into the current periodic note for the specified period relative to a heading, block refeerence, or frontmatter field within that document.
 *
 * Allows you to modify the content relative to a heading, block reference, or frontmatter field in your document.
 *
 * Note that this API was changed in Version 3.0 of this extension and the earlier PATCH API is now deprecated. Requests made using the previous version of this API will continue to work until Version 4.0 is released.  See https://github.com/coddingtonbear/obsidian-local-rest-api/wiki/Changes-to-PATCH-requests-between-versions-2.0-and-3.0 for more details and migration instructions.
 *
 * # Examples
 *
 * All of the below examples assume you have a document that looks like
 * this:
 *
 * ```markdown
 * ---
 * alpha: 1
 * beta: test
 * delta:
 * zeta: 1
 * yotta: 1
 * gamma:
 * - one
 * - two
 * ---
 *
 * # Heading 1
 *
 * This is the content for heading one
 *
 * Also references some [[#^484ef2]]
 *
 * ## Subheading 1:1
 * Content for Subheading 1:1
 *
 * ### Subsubheading 1:1:1
 *
 * ### Subsubheading 1:1:2
 *
 * Testing how block references work for a table.[[#^2c7cfa]]
 * Some content for Subsubheading 1:1:2
 *
 * More random text.
 *
 * ^2d9b4a
 *
 * ## Subheading 1:2
 *
 * Content for Subheading 1:2.
 *
 * some content with a block reference ^484ef2
 *
 * ## Subheading 1:3
 * | City         | Population |
 * | ------------ | ---------- |
 * | Seattle, WA  | 8          |
 * | Portland, OR | 4          |
 *
 * ^2c7cfa
 * ```
 *
 * ## Append Content Below a Heading
 *
 * If you wanted to append the content "Hello" below "Subheading 1:1:1" under "Heading 1",
 * you could send a request with the following headers:
 *
 * - `Operation`: `append`
 * - `Target-Type`: `heading`
 * - `Target`: `Heading 1::Subheading 1:1:1`
 * - with the request body: `Hello`
 *
 * The above would work just fine for `prepend` or `replace`, too, of course,
 * but with different results.
 *
 * ## Append Content to a Block Reference
 *
 * If you wanted to append the content "Hello" below the block referenced by
 * "2d9b4a" above ("More random text."), you could send the following headers:
 *
 * - `Operation`: `append`
 * - `Target-Type`: `block`
 * - `Target`: `2d9b4a`
 * - with the request body: `Hello`
 *
 * The above would work just fine for `prepend` or `replace`, too, of course,
 * but with different results.
 *
 * ## Add a Row to a Table Referenced by a Block Reference
 *
 * If you wanted to add a new city ("Chicago, IL") and population ("16") pair to the table above
 * referenced by the block reference `2c7cfa`, you could send the following
 * headers:
 *
 * - `Operation`: `append`
 * - `TargetType`: `block`
 * - `Target`: `2c7cfa`
 * - `Content-Type`: `application/json`
 * - with the request body: `[["Chicago, IL", "16"]]`
 *
 * The use of a `Content-Type` of `application/json` allows the API
 * to infer that member of your array represents rows and columns of your
 * to append to the referenced table.  You can of course just use a
 * `Content-Type` of `text/markdown`, but in such a case you'll have to
 * format your table row manually instead of letting the library figure
 * it out for you.
 *
 * You also have the option of using `prepend` (in which case, your new
 * row would be the first -- right below the table heading) or `replace` (in which
 * case all rows except the table heading would be replaced by the new row(s)
 * you supplied).
 *
 * ## Setting a Frontmatter Field
 *
 * If you wanted to set the frontmatter field `alpha` to `2`, you could
 * send the following headers:
 *
 * - `Operation`: `replace`
 * - `TargetType`: `frontmatter`
 * - `Target`: `beep`
 * - with the request body `2`
 *
 * If you're setting a frontmatter field that might not already exist
 * you may want to use the `Create-Target-If-Missing` header so the
 * new frontmatter field is created and set to your specified value
 * if it doesn't already exist.
 *
 * You may find using a `Content-Type` of `application/json` to be
 * particularly useful in the case of frontmatter since frontmatter
 * fields' values are JSON data, and the API can be smarter about
 * interpreting yoru `prepend` or `append` requests if you specify
 * your data as JSON (particularly when appending, for example,
 * list items).
 *
 */
export const patchPeriodicByPeriodMutation = (options?: Partial<Options<PatchPeriodicByPeriodData>>): UseMutationOptions<unknown, PatchPeriodicByPeriodError, Options<PatchPeriodicByPeriodData>> => {
    const mutationOptions: UseMutationOptions<unknown, PatchPeriodicByPeriodError, Options<PatchPeriodicByPeriodData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchPeriodicByPeriod({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Append content to the current periodic note for the specified period.
 *
 *
 * Note that this will create the relevant periodic note if necessary.
 *
 */
export const postPeriodicByPeriodMutation = (options?: Partial<Options<PostPeriodicByPeriodData>>): UseMutationOptions<PostPeriodicByPeriodResponse, PostPeriodicByPeriodError, Options<PostPeriodicByPeriodData>> => {
    const mutationOptions: UseMutationOptions<PostPeriodicByPeriodResponse, PostPeriodicByPeriodError, Options<PostPeriodicByPeriodData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postPeriodicByPeriod({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update the content of the current periodic note for the specified period.
 *
 */
export const putPeriodicByPeriodMutation = (options?: Partial<Options<PutPeriodicByPeriodData>>): UseMutationOptions<PutPeriodicByPeriodResponse, PutPeriodicByPeriodError, Options<PutPeriodicByPeriodData>> => {
    const mutationOptions: UseMutationOptions<PutPeriodicByPeriodResponse, PutPeriodicByPeriodError, Options<PutPeriodicByPeriodData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await putPeriodicByPeriod({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Delete the periodic note for the specified period and date.
 *
 *
 * Deletes the periodic note for the specified period.
 *
 */
export const deletePeriodicByPeriodByYearByMonthByDayMutation = (options?: Partial<Options<DeletePeriodicByPeriodByYearByMonthByDayData>>): UseMutationOptions<DeletePeriodicByPeriodByYearByMonthByDayResponse, DeletePeriodicByPeriodByYearByMonthByDayError, Options<DeletePeriodicByPeriodByYearByMonthByDayData>> => {
    const mutationOptions: UseMutationOptions<DeletePeriodicByPeriodByYearByMonthByDayResponse, DeletePeriodicByPeriodByYearByMonthByDayError, Options<DeletePeriodicByPeriodByYearByMonthByDayData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deletePeriodicByPeriodByYearByMonthByDay({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPeriodicByPeriodByYearByMonthByDayQueryKey = (options: Options<GetPeriodicByPeriodByYearByMonthByDayData>) => createQueryKey('getPeriodicByPeriodByYearByMonthByDay', options);

/**
 * Get the periodic note for the specified period and date.
 *
 */
export const getPeriodicByPeriodByYearByMonthByDayOptions = (options: Options<GetPeriodicByPeriodByYearByMonthByDayData>) => queryOptions<GetPeriodicByPeriodByYearByMonthByDayResponse, DefaultError, GetPeriodicByPeriodByYearByMonthByDayResponse, ReturnType<typeof getPeriodicByPeriodByYearByMonthByDayQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getPeriodicByPeriodByYearByMonthByDay({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getPeriodicByPeriodByYearByMonthByDayQueryKey(options)
});

/**
 * Partially update content in the periodic note for the specified period and date.
 *
 *
 * Inserts content into a periodic note relative to a heading, block refeerence, or frontmatter field within that document.
 *
 * Allows you to modify the content relative to a heading, block reference, or frontmatter field in your document.
 *
 * Note that this API was changed in Version 3.0 of this extension and the earlier PATCH API is now deprecated. Requests made using the previous version of this API will continue to work until Version 4.0 is released.  See https://github.com/coddingtonbear/obsidian-local-rest-api/wiki/Changes-to-PATCH-requests-between-versions-2.0-and-3.0 for more details and migration instructions.
 *
 * # Examples
 *
 * All of the below examples assume you have a document that looks like
 * this:
 *
 * ```markdown
 * ---
 * alpha: 1
 * beta: test
 * delta:
 * zeta: 1
 * yotta: 1
 * gamma:
 * - one
 * - two
 * ---
 *
 * # Heading 1
 *
 * This is the content for heading one
 *
 * Also references some [[#^484ef2]]
 *
 * ## Subheading 1:1
 * Content for Subheading 1:1
 *
 * ### Subsubheading 1:1:1
 *
 * ### Subsubheading 1:1:2
 *
 * Testing how block references work for a table.[[#^2c7cfa]]
 * Some content for Subsubheading 1:1:2
 *
 * More random text.
 *
 * ^2d9b4a
 *
 * ## Subheading 1:2
 *
 * Content for Subheading 1:2.
 *
 * some content with a block reference ^484ef2
 *
 * ## Subheading 1:3
 * | City         | Population |
 * | ------------ | ---------- |
 * | Seattle, WA  | 8          |
 * | Portland, OR | 4          |
 *
 * ^2c7cfa
 * ```
 *
 * ## Append Content Below a Heading
 *
 * If you wanted to append the content "Hello" below "Subheading 1:1:1" under "Heading 1",
 * you could send a request with the following headers:
 *
 * - `Operation`: `append`
 * - `Target-Type`: `heading`
 * - `Target`: `Heading 1::Subheading 1:1:1`
 * - with the request body: `Hello`
 *
 * The above would work just fine for `prepend` or `replace`, too, of course,
 * but with different results.
 *
 * ## Append Content to a Block Reference
 *
 * If you wanted to append the content "Hello" below the block referenced by
 * "2d9b4a" above ("More random text."), you could send the following headers:
 *
 * - `Operation`: `append`
 * - `Target-Type`: `block`
 * - `Target`: `2d9b4a`
 * - with the request body: `Hello`
 *
 * The above would work just fine for `prepend` or `replace`, too, of course,
 * but with different results.
 *
 * ## Add a Row to a Table Referenced by a Block Reference
 *
 * If you wanted to add a new city ("Chicago, IL") and population ("16") pair to the table above
 * referenced by the block reference `2c7cfa`, you could send the following
 * headers:
 *
 * - `Operation`: `append`
 * - `TargetType`: `block`
 * - `Target`: `2c7cfa`
 * - `Content-Type`: `application/json`
 * - with the request body: `[["Chicago, IL", "16"]]`
 *
 * The use of a `Content-Type` of `application/json` allows the API
 * to infer that member of your array represents rows and columns of your
 * to append to the referenced table.  You can of course just use a
 * `Content-Type` of `text/markdown`, but in such a case you'll have to
 * format your table row manually instead of letting the library figure
 * it out for you.
 *
 * You also have the option of using `prepend` (in which case, your new
 * row would be the first -- right below the table heading) or `replace` (in which
 * case all rows except the table heading would be replaced by the new row(s)
 * you supplied).
 *
 * ## Setting a Frontmatter Field
 *
 * If you wanted to set the frontmatter field `alpha` to `2`, you could
 * send the following headers:
 *
 * - `Operation`: `replace`
 * - `TargetType`: `frontmatter`
 * - `Target`: `beep`
 * - with the request body `2`
 *
 * If you're setting a frontmatter field that might not already exist
 * you may want to use the `Create-Target-If-Missing` header so the
 * new frontmatter field is created and set to your specified value
 * if it doesn't already exist.
 *
 * You may find using a `Content-Type` of `application/json` to be
 * particularly useful in the case of frontmatter since frontmatter
 * fields' values are JSON data, and the API can be smarter about
 * interpreting yoru `prepend` or `append` requests if you specify
 * your data as JSON (particularly when appending, for example,
 * list items).
 *
 */
export const patchPeriodicByPeriodByYearByMonthByDayMutation = (options?: Partial<Options<PatchPeriodicByPeriodByYearByMonthByDayData>>): UseMutationOptions<unknown, PatchPeriodicByPeriodByYearByMonthByDayError, Options<PatchPeriodicByPeriodByYearByMonthByDayData>> => {
    const mutationOptions: UseMutationOptions<unknown, PatchPeriodicByPeriodByYearByMonthByDayError, Options<PatchPeriodicByPeriodByYearByMonthByDayData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchPeriodicByPeriodByYearByMonthByDay({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Append content to the periodic note for the specified period and date.
 *
 *
 * This will create the relevant periodic note if necessary.
 *
 */
export const postPeriodicByPeriodByYearByMonthByDayMutation = (options?: Partial<Options<PostPeriodicByPeriodByYearByMonthByDayData>>): UseMutationOptions<PostPeriodicByPeriodByYearByMonthByDayResponse, PostPeriodicByPeriodByYearByMonthByDayError, Options<PostPeriodicByPeriodByYearByMonthByDayData>> => {
    const mutationOptions: UseMutationOptions<PostPeriodicByPeriodByYearByMonthByDayResponse, PostPeriodicByPeriodByYearByMonthByDayError, Options<PostPeriodicByPeriodByYearByMonthByDayData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postPeriodicByPeriodByYearByMonthByDay({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Update the content of the periodic note for the specified period and date.
 *
 */
export const putPeriodicByPeriodByYearByMonthByDayMutation = (options?: Partial<Options<PutPeriodicByPeriodByYearByMonthByDayData>>): UseMutationOptions<PutPeriodicByPeriodByYearByMonthByDayResponse, PutPeriodicByPeriodByYearByMonthByDayError, Options<PutPeriodicByPeriodByYearByMonthByDayData>> => {
    const mutationOptions: UseMutationOptions<PutPeriodicByPeriodByYearByMonthByDayResponse, PutPeriodicByPeriodByYearByMonthByDayError, Options<PutPeriodicByPeriodByYearByMonthByDayData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await putPeriodicByPeriodByYearByMonthByDay({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Search for documents matching a specified search query
 *
 *
 * Evaluates a provided query against each file in your vault.
 *
 * This endpoint supports multiple query formats.  Your query should be specified in your request's body, and will be interpreted according to the `Content-type` header you specify from the below options.Additional query formats may be added in the future.
 *
 * # Dataview DQL (`application/vnd.olrapi.dataview.dql+txt`)
 *
 * Accepts a `TABLE`-type Dataview query as a text string.  See [Dataview](https://blacksmithgu.github.io/obsidian-dataview/query/queries/)'s query documentation for information on how to construct a query.
 *
 * # JsonLogic (`application/vnd.olrapi.jsonlogic+json`)
 *
 * Accepts a JsonLogic query specified as JSON.  See [JsonLogic](https://jsonlogic.com/operations.html)'s documentation for information about the base set of operators available, but in addition to those operators the following operators are available:
 *
 * - `glob: [PATTERN, VALUE]`: Returns `true` if a string matches a glob pattern.  E.g.: `{"glob": ["*.foo", "bar.foo"]}` is `true` and `{"glob": ["*.bar", "bar.foo"]}` is `false`.
 * - `regexp: [PATTERN, VALUE]`: Returns `true` if a string matches a regular expression.  E.g.: `{"regexp": [".*\.foo", "bar.foo"]` is `true` and `{"regexp": [".*\.bar", "bar.foo"]}` is `false`.
 *
 * Returns only non-falsy results.  "Non-falsy" here treats the following values as "falsy":
 *
 * - `false`
 * - `null` or `undefined`
 * - `0`
 * - `[]`
 * - `{}`
 *
 * Files are represented as an object having the schema described
 * in the Schema named 'NoteJson' at the bottom of this page.
 * Understanding the shape of a JSON object from a schema can be
 * tricky; so you may find it helpful to examine the generated metadata
 * for individual files in your vault to understand exactly what values
 * are returned.  To see that, access the `GET` `/vault/{filePath}`
 * route setting the header:
 * `Accept: application/vnd.olrapi.note+json`.  See examples below
 * for working examples of queries performing common search operations.
 *
 */
export const postSearchMutation = (options?: Partial<Options<PostSearchData>>): UseMutationOptions<PostSearchResponse, PostSearchError, Options<PostSearchData>> => {
    const mutationOptions: UseMutationOptions<PostSearchResponse, PostSearchError, Options<PostSearchData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postSearch({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Search for documents matching a specified text query
 *
 */
export const postSearchSimpleMutation = (options?: Partial<Options<PostSearchSimpleData>>): UseMutationOptions<PostSearchSimpleResponse, DefaultError, Options<PostSearchSimpleData>> => {
    const mutationOptions: UseMutationOptions<PostSearchSimpleResponse, DefaultError, Options<PostSearchSimpleData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postSearchSimple({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getVaultQueryKey = (options?: Options<GetVaultData>) => createQueryKey('getVault', options);

/**
 * List files that exist in the root of your vault.
 *
 *
 * Lists files in the root directory of your vault.
 *
 * Note: that this is exactly the same API endpoint as the below "List files that exist in the specified directory." and exists here only due to a quirk of this particular interactive tool.
 *
 */
export const getVaultOptions = (options?: Options<GetVaultData>) => queryOptions<GetVaultResponse, GetVaultError, GetVaultResponse, ReturnType<typeof getVaultQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getVault({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getVaultQueryKey(options)
});

/**
 * Delete a particular file in your vault.
 *
 */
export const deleteVaultByFilenameMutation = (options?: Partial<Options<DeleteVaultByFilenameData>>): UseMutationOptions<DeleteVaultByFilenameResponse, DeleteVaultByFilenameError, Options<DeleteVaultByFilenameData>> => {
    const mutationOptions: UseMutationOptions<DeleteVaultByFilenameResponse, DeleteVaultByFilenameError, Options<DeleteVaultByFilenameData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await deleteVaultByFilename({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getVaultByFilenameQueryKey = (options: Options<GetVaultByFilenameData>) => createQueryKey('getVaultByFilename', options);

/**
 * Return the content of a single file in your vault.
 *
 *
 * Returns the content of the file at the specified path in your vault should the file exist.
 *
 * If you specify the header `Accept: application/vnd.olrapi.note+json`, will return a JSON representation of your note including parsed tag and frontmatter data as well as filesystem metadata.  See "responses" below for details.
 *
 */
export const getVaultByFilenameOptions = (options: Options<GetVaultByFilenameData>) => queryOptions<GetVaultByFilenameResponse, DefaultError, GetVaultByFilenameResponse, ReturnType<typeof getVaultByFilenameQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getVaultByFilename({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getVaultByFilenameQueryKey(options)
});

/**
 * Partially update content in an existing note.
 *
 *
 * Inserts content into an existing note relative to a heading, block refeerence, or frontmatter field within that document.
 *
 * Allows you to modify the content relative to a heading, block reference, or frontmatter field in your document.
 *
 * Note that this API was changed in Version 3.0 of this extension and the earlier PATCH API is now deprecated. Requests made using the previous version of this API will continue to work until Version 4.0 is released.  See https://github.com/coddingtonbear/obsidian-local-rest-api/wiki/Changes-to-PATCH-requests-between-versions-2.0-and-3.0 for more details and migration instructions.
 *
 * # Examples
 *
 * All of the below examples assume you have a document that looks like
 * this:
 *
 * ```markdown
 * ---
 * alpha: 1
 * beta: test
 * delta:
 * zeta: 1
 * yotta: 1
 * gamma:
 * - one
 * - two
 * ---
 *
 * # Heading 1
 *
 * This is the content for heading one
 *
 * Also references some [[#^484ef2]]
 *
 * ## Subheading 1:1
 * Content for Subheading 1:1
 *
 * ### Subsubheading 1:1:1
 *
 * ### Subsubheading 1:1:2
 *
 * Testing how block references work for a table.[[#^2c7cfa]]
 * Some content for Subsubheading 1:1:2
 *
 * More random text.
 *
 * ^2d9b4a
 *
 * ## Subheading 1:2
 *
 * Content for Subheading 1:2.
 *
 * some content with a block reference ^484ef2
 *
 * ## Subheading 1:3
 * | City         | Population |
 * | ------------ | ---------- |
 * | Seattle, WA  | 8          |
 * | Portland, OR | 4          |
 *
 * ^2c7cfa
 * ```
 *
 * ## Append Content Below a Heading
 *
 * If you wanted to append the content "Hello" below "Subheading 1:1:1" under "Heading 1",
 * you could send a request with the following headers:
 *
 * - `Operation`: `append`
 * - `Target-Type`: `heading`
 * - `Target`: `Heading 1::Subheading 1:1:1`
 * - with the request body: `Hello`
 *
 * The above would work just fine for `prepend` or `replace`, too, of course,
 * but with different results.
 *
 * ## Append Content to a Block Reference
 *
 * If you wanted to append the content "Hello" below the block referenced by
 * "2d9b4a" above ("More random text."), you could send the following headers:
 *
 * - `Operation`: `append`
 * - `Target-Type`: `block`
 * - `Target`: `2d9b4a`
 * - with the request body: `Hello`
 *
 * The above would work just fine for `prepend` or `replace`, too, of course,
 * but with different results.
 *
 * ## Add a Row to a Table Referenced by a Block Reference
 *
 * If you wanted to add a new city ("Chicago, IL") and population ("16") pair to the table above
 * referenced by the block reference `2c7cfa`, you could send the following
 * headers:
 *
 * - `Operation`: `append`
 * - `TargetType`: `block`
 * - `Target`: `2c7cfa`
 * - `Content-Type`: `application/json`
 * - with the request body: `[["Chicago, IL", "16"]]`
 *
 * The use of a `Content-Type` of `application/json` allows the API
 * to infer that member of your array represents rows and columns of your
 * to append to the referenced table.  You can of course just use a
 * `Content-Type` of `text/markdown`, but in such a case you'll have to
 * format your table row manually instead of letting the library figure
 * it out for you.
 *
 * You also have the option of using `prepend` (in which case, your new
 * row would be the first -- right below the table heading) or `replace` (in which
 * case all rows except the table heading would be replaced by the new row(s)
 * you supplied).
 *
 * ## Setting a Frontmatter Field
 *
 * If you wanted to set the frontmatter field `alpha` to `2`, you could
 * send the following headers:
 *
 * - `Operation`: `replace`
 * - `TargetType`: `frontmatter`
 * - `Target`: `beep`
 * - with the request body `2`
 *
 * If you're setting a frontmatter field that might not already exist
 * you may want to use the `Create-Target-If-Missing` header so the
 * new frontmatter field is created and set to your specified value
 * if it doesn't already exist.
 *
 * You may find using a `Content-Type` of `application/json` to be
 * particularly useful in the case of frontmatter since frontmatter
 * fields' values are JSON data, and the API can be smarter about
 * interpreting yoru `prepend` or `append` requests if you specify
 * your data as JSON (particularly when appending, for example,
 * list items).
 *
 */
export const patchVaultByFilenameMutation = (options?: Partial<Options<PatchVaultByFilenameData>>): UseMutationOptions<unknown, PatchVaultByFilenameError, Options<PatchVaultByFilenameData>> => {
    const mutationOptions: UseMutationOptions<unknown, PatchVaultByFilenameError, Options<PatchVaultByFilenameData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await patchVaultByFilename({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Append content to a new or existing file.
 *
 *
 * Appends content to the end of an existing note. If the specified file does not yet exist, it will be created as an empty file.
 *
 * If you would like to insert text relative to a particular heading, block reference, or frontmatter field instead of appending to the end of the file, see 'patch'.
 *
 */
export const postVaultByFilenameMutation = (options?: Partial<Options<PostVaultByFilenameData>>): UseMutationOptions<PostVaultByFilenameResponse, PostVaultByFilenameError, Options<PostVaultByFilenameData>> => {
    const mutationOptions: UseMutationOptions<PostVaultByFilenameResponse, PostVaultByFilenameError, Options<PostVaultByFilenameData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await postVaultByFilename({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

/**
 * Create a new file in your vault or update the content of an existing one.
 *
 *
 * Creates a new file in your vault or updates the content of an existing one if the specified file already exists.
 *
 */
export const putVaultByFilenameMutation = (options?: Partial<Options<PutVaultByFilenameData>>): UseMutationOptions<PutVaultByFilenameResponse, PutVaultByFilenameError, Options<PutVaultByFilenameData>> => {
    const mutationOptions: UseMutationOptions<PutVaultByFilenameResponse, PutVaultByFilenameError, Options<PutVaultByFilenameData>> = {
        mutationFn: async (fnOptions) => {
            const { data } = await putVaultByFilename({
                ...options,
                ...fnOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getVaultByPathToDirectoryQueryKey = (options: Options<GetVaultByPathToDirectoryData>) => createQueryKey('getVaultByPathToDirectory', options);

/**
 * List files that exist in the specified directory.
 *
 */
export const getVaultByPathToDirectoryOptions = (options: Options<GetVaultByPathToDirectoryData>) => queryOptions<GetVaultByPathToDirectoryResponse, GetVaultByPathToDirectoryError, GetVaultByPathToDirectoryResponse, ReturnType<typeof getVaultByPathToDirectoryQueryKey>>({
    queryFn: async ({ queryKey, signal }) => {
        const { data } = await getVaultByPathToDirectory({
            ...options,
            ...queryKey[0],
            signal,
            throwOnError: true
        });
        return data;
    },
    queryKey: getVaultByPathToDirectoryQueryKey(options)
});
