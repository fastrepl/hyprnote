use specta::TypeCollection;
use specta_zod::Zod;

include!("src/types.rs");

fn main() {
    let mut types = TypeCollection::default();
    types.register::<Human>();
    types.register::<Event>();
    types.register::<Calendar>();
    types.register::<Organization>();
    types.register::<Session>();
    types.register::<Transcript>();
    types.register::<MappingSessionParticipant>();
    types.register::<Tag>();
    types.register::<MappingTagSession>();
    types.register::<TemplateSection>();
    types.register::<Template>();
    types.register::<ChatGroup>();
    types.register::<ChatMessage>();
    types.register::<ChatShortcut>();
    types.register::<EnhancedNote>();
    types.register::<Prompt>();
    types.register::<Word>();
    types.register::<SpeakerHint>();
    types.register::<General>();

    let header = r#"// This file is auto-generated by building store-types crate.
// Do not edit this file manually. Instead, edit the Rust types in
// crates/store-types/src/types.rs and run `cargo build -p store-types`.

import { z } from "zod";

import { jsonObject } from "./shared";

export const calendarProviderSchema = z.enum(["apple", "google", "outlook"]);
export type CalendarProvider = z.infer<typeof calendarProviderSchema>;

export const participantSourceSchema = z.enum(["manual", "auto", "excluded"]);
export type ParticipantSource = z.infer<typeof participantSourceSchema>;

"#;

    let zod_output = Zod::new().header(header).export(&types).unwrap();
    let zod_output = reorder_template_schemas(&zod_output);

    let footer = r#"
export const providerSpeakerIndexSchema = z.object({
  speaker_index: z.number(),
  provider: z.string().optional(),
  channel: z.number().optional(),
});
export type ProviderSpeakerIndexHint = z.infer<typeof providerSpeakerIndexSchema>;

export const aiProviderSchema = z
  .object({
    type: z.enum(["stt", "llm"]),
    base_url: z.url().min(1),
    api_key: z.string(),
  })
  .refine(
    (data) => !data.base_url.startsWith("https:") || data.api_key.length > 0,
    {
      message: "API key is required for HTTPS URLs",
      path: ["api_key"],
    },
  );
export type AIProvider = z.infer<typeof aiProviderSchema>;
"#;

    let output = format!("{}{}", zod_output, footer);

    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").unwrap();
    let output_path = std::path::Path::new(&manifest_dir).join("../../packages/store/src/zod.ts");
    std::fs::write(&output_path, output).expect("Failed to write zod.ts");

    println!("cargo::rerun-if-changed=src/types.rs");
}

fn reorder_template_schemas(output: &str) -> String {
    let template_marker = "export const templateSchema = z.object({";
    let section_marker = "export const templateSectionSchema = z.object({";

    let Some(template_start) = output.find(template_marker) else {
        return output.to_string();
    };
    let Some(section_start) = output.find(section_marker) else {
        return output.to_string();
    };

    if template_start > section_start {
        return output.to_string();
    }

    let template_end = find_type_block_end(output, template_start);
    let section_end = find_type_block_end(output, section_start);

    let template_block = &output[template_start..template_end];
    let section_block = &output[section_start..section_end];

    let before = &output[..template_start];
    let between = &output[template_end..section_start];
    let after = &output[section_end..];

    format!(
        "{}{}{}{}{}",
        before, section_block, between, template_block, after
    )
}

fn find_type_block_end(content: &str, start: usize) -> usize {
    let from_start = &content[start..];
    if let Some(next) = from_start[1..].find("\nexport const ") {
        start + 1 + next + 1
    } else {
        content.len()
    }
}
