# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Hyprnote is an AI-powered notepad for meetings that works locally using open-source models (Whisper & Llama). It's a local-first, privacy-focused desktop application built with Tauri v2 (Rust) and React (TypeScript).

## Essential Commands

### Development
```bash
# Install dependencies (requires pnpm 10.11.1)
pnpm install

# Run desktop app in development mode
turbo -F @hypr/desktop tauri:dev
# or
cd apps/desktop && pnpm tauri:dev

# Build desktop app
turbo -F @hypr/desktop tauri:build

# Type checking
pnpm -r typecheck

# Format code
dprint fmt

# Extract and compile translations
cd apps/desktop && pnpm lingui:extract && pnpm lingui:compile
```

### Testing
```bash
# Run TypeScript tests
pnpm -r test

# Run Rust tests for a specific crate
cd crates/<crate-name> && cargo test

# Run Rust tests for all crates
cargo test --workspace
```

### Prerequisites Installation
```bash
# macOS
brew install libomp cmake

# Install Rust (required)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

## Architecture

### Tech Stack
- **Frontend**: React + TypeScript, Vite, TanStack Router/Query, Zustand, Tailwind CSS
- **Desktop Framework**: Tauri v2 (Rust-based)
- **Rich Text Editor**: Tiptap with custom mention system
- **AI Models**: Local Whisper (STT), Local/Cloud Llama (text generation)
- **Database**: SQLite via libsql

### Key Architecture Patterns

1. **Plugin Architecture**: All functionality is modularized into Tauri plugins located in `/plugins/`:
   - Each plugin has TypeScript bindings auto-generated to `/plugins/<name>/js/bindings.gen.ts`
   - Permissions are defined in `/plugins/<name>/permissions/default.toml`
   - New commands require permission entries

2. **State Management**:
   - Global state: Zustand stores in `/packages/utils/src/contexts/`
   - Server state: React Query for caching and synchronization
   - Session-specific state: Per-session Zustand stores

3. **Data Flow**:
   - Frontend calls plugin commands via generated TypeScript bindings
   - Rust plugins handle business logic and database operations
   - Real-time updates via Tauri events

4. **Component Structure**:
   - `/apps/desktop/src/components/`: Shared UI components
   - Feature-specific components are colocated with their routes
   - Common UI components in `/packages/ui/`

### Important Conventions

1. **Mentions System**:
   - Mentions are stored as HTML: `<a class="mention" data-mention="true" data-id="..." data-type="note|human" ...>`
   - Search for mentions requires checking both `enhanced_memo_html` and `raw_memo_html` fields
   - Mention navigation differs by type (notes use routing, humans use window popups)

2. **Database Operations**:
   - All DB operations go through `/crates/db-user/src/`
   - New operations need: Rust implementation ÔøΩ Tauri command ÔøΩ Permission entry ÔøΩ TypeScript binding

3. **Permissions**:
   - New Tauri commands require entries in `/plugins/<name>/permissions/default.toml`
   - Individual permission files in `/permissions/autogenerated/commands/`

4. **Session Management**:
   - Sessions represent notes/meetings
   - Each session has: raw HTML, enhanced HTML, participants, words (transcript)
   - Session IDs are used as primary keys across features

5. **Chat Persistence**:
   - Chat messages are stored per session using session ID as group ID
   - Messages include role (User/Assistant) and are loaded on session navigation

## Common Development Tasks

### Adding a New Database Operation
1. Add function to appropriate `*_ops.rs` file in `/crates/db-user/src/`
2. Create Tauri command in `/plugins/db/src/commands/`
3. Register command in `/plugins/db/src/lib.rs`
4. Add permission to `/plugins/db/permissions/default.toml`
5. Create permission file in `/plugins/db/permissions/autogenerated/commands/`
6. Run build to generate TypeScript bindings

### Adding a New UI Component
1. Create component in appropriate location under `/apps/desktop/src/components/`
2. Use existing patterns (Popover for dropdowns, consistent styling)
3. Import Lucide icons for consistency
4. Follow existing hover states and color schemes

### Modifying Tiptap Editor
1. Editor extensions are in `/packages/tiptap/src/editor/`
2. Mention system uses custom extension with floating UI
3. Styles are in `/packages/tiptap/src/styles/`

## Build System

- **Monorepo**: pnpm workspaces + Turborepo
- **Parallel builds**: Turbo handles dependency graph
- **Caching**: Turbo caches build outputs
- **CI/CD**: GitHub Actions for macOS/Windows builds

## Code Quality Tools

- **Formatting**: dprint (configured in `.dprint.json`)
- **Type Checking**: TypeScript strict mode
- **Rust**: cargo fmt, cargo clippy

## Debugging Tips

1. **Rust Logs**: Use `println!` or `tracing` macros - output appears in terminal
2. **Frontend Logs**: Browser DevTools console in Tauri window
3. **Database Issues**: Check SQLite schema in `/crates/db-user/src/*_migration.sql`
4. **Permission Errors**: Verify command is in default.toml and has permission file

## Recent Features Implementation Patterns

### Backlinks/Related Notes
- Database query searches for mentions using `data-id` attribute
- UI shows as chip component with popover
- Real-time updates via React Query

### Chat Persistence
- Messages stored in `chat_messages` table linked to sessions
- Auto-saves on send, loads on session navigation
- Supports markdown content with parsed blocks

### People Mentions
- Extended mention system to support multiple types
- Different click handlers based on mention type
- Visual distinction with icons and colors

## Chat System Architecture (v2 - Refactored with Vercel AI SDK v5)

### Overview
The chat system has been completely refactored to use Vercel AI SDK v5's `useChat` hook with custom transport implementation. It provides session-based AI chat with persistence, streaming support, and MCP tool integration.

### Critical Files for Chat System (Must NOT Delete)
- `/apps/desktop/src/components/right-panel/views/chat-view.tsx` - Main chat orchestrator component
- `/apps/desktop/src/components/right-panel/utils/chat-transport.ts` - Custom transport wrapping streamText
- `/apps/desktop/src/components/right-panel/hooks/useChat2.ts` - useChat wrapper with custom transport
- `/apps/desktop/src/components/right-panel/hooks/useChatQueries2.ts` - Database queries for new schema
- `/apps/desktop/src/components/right-panel/components/chat/ui-message.tsx` - Unified message renderer
- `/apps/desktop/src/components/right-panel/utils/markdown-parser.ts` - Detects markdown blocks during streaming
- `/apps/desktop/src/components/right-panel/components/chat/markdown-card.tsx` - Renders markdown blocks with Apply button
- `/apps/desktop/src/components/right-panel/components/chat/chat-messages-view.tsx` - Message list with thinking indicator
- `/apps/desktop/src/components/right-panel/components/chat/chat-input.tsx` - Input with mentions support

### Key Refactoring Changes (December 2024)
- **Migration to UIMessage**: Replaced custom Message type with Vercel AI SDK's UIMessage structure
- **Custom Transport**: Implemented ChatTransport interface wrapping streamText (no API endpoints needed)
- **Simplified Rendering**: Single UIMessageComponent renders all message types via parts array
- **New Database Schema**: chat_conversations and chat_messages_v2 tables store UIMessage-compatible structure
- **Direct useChat Integration**: Leverages Vercel AI SDK's built-in streaming and state management

### CRITICAL ARCHITECTURAL ISSUE
**The `useChat` hook from Vercel AI SDK is designed for single conversation threads and doesn't support switching between conversations or loading historical messages.** This is a fundamental limitation that requires one of these solutions:

1. **Create new useChat instance per conversation** (recommended)
2. **Don't use useChat at all** - manage streaming manually with streamText
3. **Accept the limitation** - only support single active conversation per session

### Recently Fixed Issues (useChat Refactor)
1. **Loading Historical Messages**: Fixed - useChat DOES have setMessages method (was wrong about this limitation)
2. **Conversation ID Timing**: Fixed - pass conversation ID directly in sendMessage options
3. **New Chat Clearing**: Fixed - use setMessages([]) instead of page reload hack
4. **Stale Closures**: Fixed - use refs for conversation ID in onFinish callback
5. **Message State Duplication**: Fixed - removed duplicate state, only using useChat's messages

### Remaining Minor Issues
1. **createdAt Field**: UIMessage doesn't have createdAt, using type assertions as workaround
2. **handleApplyMarkdown**: Not implemented yet, Apply button on markdown cards needs implementation
3. **Type Mismatches**: markdown-parser expects MessagePart but gets UIMessage parts (works but has type warnings)

### Core Components

#### 1. Chat View (`/apps/desktop/src/components/right-panel/views/chat-view.tsx`)
- Main container component using useChat2 and useChatQueries2 hooks
- Manages UI state: messages (UIMessage[]), input value, history visibility, conversation ID
- Integrates with session context via `useActiveEntity` hook
- Handles conversation creation and navigation
- Renders either chat history view or active chat interface with UIMessageComponent

#### 2. useChat2 Hook (`/apps/desktop/src/components/right-panel/hooks/useChat2.ts`)
- **Core responsibility**: Wrapper around Vercel AI SDK's useChat with custom transport
- **Key features**:
  - Uses CustomChatTransport implementing ChatTransport interface
  - Handles message persistence to chat_messages_v2 table
  - Manages session-specific context and metadata
  - Provides sendMessage helper for user messages with metadata
  - Automatic cleanup of MCP clients on unmount

**Message Processing Flow**:
1. User message ÔøΩ Check license ÔøΩ Analytics ÔøΩ Create message object ÔøΩ Save to DB
2. Initialize AI streaming with model provider and MCP tools
3. Process stream chunks: text-delta updates existing message, tool calls create new messages
4. Each message type saved to DB with appropriate metadata
5. Handle errors with user-friendly messages

#### 3. useChatQueries2 Hook (`/apps/desktop/src/components/right-panel/hooks/useChatQueries2.ts`)
- Manages all database queries for chat functionality with new schema
- **Key queries**:
  - `conversationsQuery`: Lists all conversations for a session with first message preview
  - `messagesQuery`: Loads UIMessage-formatted messages from chat_messages_v2
  - `sessionData`: Fetches session context (title, content, words)
- **Smart syncing**: Prevents DB overwrites during active generation
- Auto-selects most recent conversation on session change
- Creates new conversations on demand via `getOrCreateConversationId()`

#### 4. CustomChatTransport (`/apps/desktop/src/components/right-panel/utils/chat-transport.ts`)
- Implements ChatTransport interface from Vercel AI SDK
- Wraps streamText with MCP tools and model configuration
- Loads MCP tools dynamically based on model capabilities
- Converts stream to UIMessageStream format
- Handles cleanup of MCP clients after streaming

#### 5. Chat Input Component (`/apps/desktop/src/components/right-panel/components/chat/chat-input.tsx`)
- Rich text editor using Tiptap with mention support
- **Mention System**:
  - Triggered by "@" character
  - Searches notes (sessions) and people (humans)
  - Stores mentions as HTML: `<a class="mention" data-id="..." data-type="..." data-label="...">`
  - Extracts mentioned content before submission
- **Selection References**:
  - Handles text selections from notes via `pendingSelection`
  - Creates compact references like `[Note Title - 'selected...'(start:end)]`
  - Passes selection data through to AI for context
- Entity badge shows current note/human/organization context
- Submit button transforms to stop button during generation

#### 6. UIMessageComponent (`/apps/desktop/src/components/right-panel/components/chat/ui-message.tsx`)
- Single component for rendering all UIMessage types
- Renders message.parts array directly:
  - **text parts**: Parses for markdown blocks using parseMarkdownBlocks()
    - Regular text: Rendered with Tiptap Renderer
    - Markdown blocks (```): Rendered as MarkdownCard with Apply button
  - **tool-call parts**: Collapsible accordion with tool name and args
  - **tool-result parts**: Status messages with completion indicator
- User messages: Right-aligned with border and timestamp
- Assistant messages: Left-aligned, renders parts sequentially
- Preserves HTML content from metadata for mentions/selections
- **IMPORTANT**: Markdown block detection during streaming is preserved via markdown-parser.ts

### Data Models

#### UIMessage Structure (Vercel AI SDK v5)
```typescript
interface UIMessage {
  id: string;
  role: "user" | "assistant" | "system";
  parts: UIPart[]; // Array of text, tool-call, tool-result parts
  metadata?: any; // Custom metadata (htmlContent, mentions, etc.)
  createdAt?: Date; // Added during DB retrieval
}
```

#### Database Schema (v2)
- **chat_conversations**: Links conversations to sessions (id, session_id, user_id, name, created_at, updated_at)
- **chat_messages_v2**: Stores UIMessage structure (id, conversation_id, role, parts as JSON, metadata as JSON, created_at, updated_at)

### State Management

#### Local State (React)
- Messages array maintained in chat-view, updated during streaming
- Input value controlled by chat-view
- Generation status tracked with `isGenerating` and `isStreamingText`
- Abort controller refs for cancellation

#### Persistent State (Database)
- Messages saved immediately on creation (not batched)
- Chat groups created lazily on first message
- Session association maintained via session_id

### MCP Tools Integration
- Dynamically loads MCP tools from enabled servers
- Pro users get access to Hyprnote's cloud MCP server
- Tools wrapped with Vercel AI SDK's `dynamicTool`
- Tool execution creates special message types for UI feedback
- Tools have access to session context and selection data

### Key Implementation Details

1. **Streaming Handling**:
   - Uses `smoothStream` for better UX with 70ms delay and word chunking
   - Different chunk types trigger different UI updates
   - Text accumulates in existing message, tools create new messages

2. **Context Preparation**:
   - `prepareMessageHistory` formats messages for AI model
   - Includes session data, mentioned content, and selection context
   - Adapts format based on model requirements

3. **Error Recovery**:
   - Graceful handling of cancellations
   - User-friendly error messages for common issues
   - Maintains UI state consistency on errors

4. **Performance Optimizations**:
   - Prevents DB queries during active generation
   - Debounced mention search with analytics tracking
   - Efficient message updates using ID-based mapping

## Important Instruction Reminders
Do what has been asked; nothing more, nothing less.
NEVER create files unless they're absolutely necessary for achieving your goal.
ALWAYS prefer editing an existing file to creating a new one.
NEVER proactively create documentation files (*.md) or README files. Only create documentation files if explicitly requested by the User.

## What user actually experiences with chat (this must be maintained no matter what)
1. Sending a chat and receiving response 
- right after the user sends a message, user should get immediate visual feedback (seeing thinking...) message appearing as the ai response. 
- as streaming starts, this thinking... message disappears and ai text message starts streming. 
- when user is waiting for the ai response to finish streaming, chat input will be inactive (so user cannot send new message). 

2. tool results/call UI 
- IT is paramount that the current practice for tool UIs gets maintained 
- for example, if AI response is (text)(tool call)(more text), response should be streamed in this exact order.

**How the code handles this (from useChatLogic.ts lines 362-512):**
- The streaming loop tracks `lastChunkType` to detect transitions between message types
- When transitioning from text to tool (and vice versa), the code:
  1. Sets `isStreamingText` to false when text stops (line 364)
  2. Adds a 50ms delay for visual separation (line 366)
  3. Creates new message entries for each tool interaction

**Message type flow in the UI:**
- `text-delta`: Accumulates in the same message, updates content incrementally
- `tool-call`: Creates a new "tool-start" message with collapsible details (lines 436-455)
- `tool-result`: Creates a new completion message (lines 469-487)
- `tool-error`: Creates an error message with the error details (lines 492-509)

**Visual representation in MessageContent component:**
- Tool start messages show with PencilRuler icon and gray background (#fafafa)
- Tool details are in an accordion (collapsible) with monospace font
- Tool results show as separate status messages
- Each message type has distinct styling to maintain visual hierarchy


3. Storing to DB 
- there are difference with UI types of chat messages and what actually gets stored in the DB 

**UI Message Types vs DB Storage:**

**User Messages (lines 171-190 in useChatLogic.ts):**
- UI: Shows with `isUser: true`, may include visual mention badges and selection references
- DB: Stored with `role: "User"`, `type: "text-delta"`
- Special handling: `toolDetails` field stores HTML content with mentions/selections as JSON string

**AI Text Messages (lines 515-524):**
- UI: Shows streaming text with markdown parsing, `parts` array for structured content
- DB: Stored with `role: "Assistant"`, `type: "text-delta"`, plain content string
- Timing: Saved after streaming completes or when transitioning to tool call

**Tool Messages (lines 447-509):**
- **tool-start**: 
  - UI: Collapsible accordion with tool name and parameters
  - DB: `type: "tool-start"`, `tool_details: JSON.stringify(chunk.input)`
- **tool-result**: 
  - UI: Simple status message "Tool finished: {name}"
  - DB: `type: "tool-result"`, `tool_details: null`
- **tool-error**:
  - UI: Error message with details
  - DB: `type: "tool-error"`, `tool_details: null`

**Key Differences:**
1. **Immediate persistence**: Each message saved to DB as soon as created (not batched)
2. **HTML content preservation**: User messages with mentions stored as HTML in `tool_details`
3. **Markdown parsing**: Only happens on retrieval for display (line 99 in useChatQueries.ts)
4. **Message reconstruction**: When loading from DB, `parts` are regenerated via `parseMarkdownBlocks()`

## Chat System V2 - Vercel AI SDK 5 Refactoring (Master Plan)

### Overview
Complete migration from custom chat implementation to Vercel AI SDK 5's `useChat` hook. This refactoring removes backward compatibility concerns and modernizes the entire chat system while maintaining the exact user experience.

### New Architecture Components

#### 1. Custom Transport (`/apps/desktop/src/services/chat-transport.ts`)
**Purpose**: Bridge between useChat and streamText without an API endpoint
```typescript
// Key structure:
class CustomChatTransport implements ChatTransport {
  async send(args: {
    messages: UIMessage[];
    onData: (data: any) => void;
    onFinish: () => void;
    onError: (error: Error) => void;
    signal?: AbortSignal;
  }) {
    // 1. Convert UIMessages to AI SDK format
    // 2. Load MCP tools dynamically
    // 3. Call streamText directly
    // 4. Transform stream chunks to UIMessage parts
    // 5. Handle tool calls, text streaming, errors
  }
}
```

#### 2. Database Schema V2
```sql
-- Replace old tables completely
CREATE TABLE chat_conversations (
    id TEXT PRIMARY KEY,
    session_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    name TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (session_id) REFERENCES sessions(id)
);

CREATE TABLE chat_messages_v2 (
    id TEXT PRIMARY KEY,
    conversation_id TEXT NOT NULL,
    role TEXT CHECK(role IN ('system', 'user', 'assistant')) NOT NULL,
    parts JSON NOT NULL, -- Array of UIMessagePart objects
    metadata JSON, -- Stores mentions, selections, etc.
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (conversation_id) REFERENCES chat_conversations(id)
);

-- Indexes for performance
CREATE INDEX idx_conversations_session ON chat_conversations(session_id);
CREATE INDEX idx_messages_conversation ON chat_messages_v2(conversation_id);
```

#### 3. New Files to Create

**`/apps/desktop/src/services/chat-transport.ts`**
- Implements ChatTransport interface
- Wraps streamText with model provider
- Handles MCP tool integration
- Transforms stream to UIMessage format
- Manages abort signals

**`/apps/desktop/src/hooks/useChat2.ts`**
- Wrapper around Vercel's useChat
- Configures custom transport
- Handles persistence callbacks
- Manages tool call results
- Provides loading state

**`/apps/desktop/src/hooks/useChatQueries2.ts`**
- Simplified database queries
- Loads conversations list
- Provides initial messages
- Creates new conversations
- No complex state syncing

**`/apps/desktop/src/components/right-panel/utils/message-part-renderer.tsx`**
- Renders individual message parts
- Handles text, tool, error parts
- Maintains current visual styling
- Reusable component

**`/crates/db-user/src/chat_v2_ops.rs`**
- CRUD operations for new schema
- Efficient JSON handling for parts
- Batch operations support

**`/crates/db-user/src/chat_v2_migration.sql`**
- Creates new tables
- Sets up indexes
- No data migration (clean slate)

**`/plugins/db/src/commands/chat_v2.rs`**
- Tauri commands for chat operations
- Type-safe bindings
- Error handling

### Implementation Phases

#### Phase 1: Database Layer
1. Create migration script with new schema
2. Implement Rust operations in `chat_v2_ops.rs`
3. Add Tauri commands in `chat_v2.rs`
4. Update permissions in `permissions/default.toml`
5. Generate TypeScript bindings

#### Phase 2: Transport Implementation
1. Create `CustomChatTransport` class
2. Implement message conversion utilities
3. Add MCP tool loading logic
4. Handle stream transformation
5. Test with mock data

#### Phase 3: Hook Integration
1. Implement `useChat2` with custom transport
2. Add persistence in `onFinish` callback
3. Create `useChatQueries2` for data loading
4. Handle conversation management
5. Test initial message loading

#### Phase 4: UI Updates
1. Update `chat-view.tsx` to use new hooks
2. Create `message-part-renderer.tsx`
3. Update `message-content.tsx` for UIMessage
4. Maintain exact visual styling
5. Preserve all interactions

#### Phase 5: Cleanup
1. Remove old chat-related files
2. Update imports throughout codebase
3. Remove old database tables
4. Update tests
5. Verify feature parity

### Critical Implementation Details

#### Message Format Transformation
```typescript
// UIMessage structure (what useChat expects)
interface UIMessage {
  id: string;
  role: 'system' | 'user' | 'assistant';
  parts: Array<
    | { type: 'text'; text: string; state?: 'streaming' | 'done' }
    | { type: 'tool-${string}'; toolCallId: string; state: string; input?: any; output?: any }
  >;
  metadata?: {
    mentions?: Array<{id: string; type: string; label: string}>;
    selectionData?: SelectionData;
    htmlContent?: string;
  };
}

// Transform from stream chunks to UIMessage parts
function transformChunkToUIPart(chunk: any): UIMessagePart {
  if (chunk.type === 'text-delta') {
    return { type: 'text', text: chunk.text, state: 'streaming' };
  }
  if (chunk.type === 'tool-call') {
    return {
      type: `tool-${chunk.toolName}`,
      toolCallId: chunk.toolCallId,
      state: 'input-available',
      input: chunk.input
    };
  }
  // ... handle other chunk types
}
```

#### Tool Handling Strategy
- Tools are loaded dynamically in transport
- Tool calls create new parts in assistant message
- Tool results update existing parts
- Visual progression: input-streaming ‚Üí input-available ‚Üí output-available
- Error states handled with output-error

#### Persistence Strategy
```typescript
// In useChat2 hook
const { messages, append, stop } = useChat({
  transport: customTransport,
  onFinish: async (message) => {
    // Save to database
    await dbCommands.saveMessageV2({
      id: message.id,
      conversation_id: currentConversationId,
      role: message.role,
      parts: JSON.stringify(message.parts),
      metadata: JSON.stringify(message.metadata)
    });
  },
  messages: initialMessages // From useChatQueries2
});
```

### User Experience Preservation Requirements

#### MUST Maintain:
1. **"Thinking..." indicator** before streaming starts
2. **Input disabled** during generation
3. **Tool UI hierarchy**: collapsible accordions with details
4. **Mention system**: @ triggers, HTML storage
5. **Selection references**: highlighted text from notes
6. **Stop button** replaces submit during generation
7. **Message ordering**: text ‚Üí tool ‚Üí text flow
8. **Visual delays** between different message types

#### Visual Specifications:
- Tool messages: Gray background (#fafafa), PencilRuler icon
- Tool details: Monospace font in accordion
- Mentions: Blue highlight with rounded corners
- Streaming text: Smooth word-by-word appearance
- Error messages: User-friendly with details

### Testing Strategy

1. **Unit Tests**:
   - Transport message transformation
   - Tool handling logic
   - Database operations

2. **Integration Tests**:
   - Full chat flow
   - Tool execution
   - Persistence

3. **E2E Tests**:
   - User experience preservation
   - Performance with large histories
   - Error recovery

### Common Pitfalls to Avoid

1. **Don't batch DB saves** - Save immediately on message creation
2. **Preserve HTML content** - Mentions must stay as HTML
3. **Handle streaming states** - Track text vs tool transitions
4. **Maintain visual delays** - 50ms pause between message types
5. **Keep tool details** - Must be collapsible with full parameters

### Rollback Strategy

If issues arise:
1. Keep old tables during development
2. Feature flag for new vs old system
3. Export/import utility for data migration
4. Parallel testing environment

### Migration Progress (As of 2025-09-04)

#### ‚ö†Ô∏è IMPORTANT: Work In Progress - Not Yet Functional
**This migration is incomplete and the code has several critical issues that need to be resolved before it can work:**

1. **TypeScript Compilation Errors**: Multiple type mismatches between database types and UI types
2. **Untested Integration**: No components have been updated to use the new system yet
3. **Missing Conversions**: Database messages don't properly convert to UIMessage format
4. **Incomplete Implementation**: Several helper functions and utilities are missing

#### Summary of Work Attempted (Not Yet Working)
We've started migrating the chat system to Vercel AI SDK v5, but significant work remains:

**What's Been Created (But Not Tested):**
1. **Database Schema**: 
   - Created new tables `chat_conversations` and `chat_messages_v2`
   - Schema designed to store UIMessage format but conversions not implemented correctly
   - Missing proper role enum handling

2. **Rust Backend**: 
   - Basic CRUD operations created but not integrated with frontend
   - Tauri commands registered but not tested
   - Missing error handling for edge cases

3. **Custom Transport**: 
   - `CustomChatTransport` class created but has type issues
   - MCP tools integration copied from old code but not verified
   - Model initialization has type assertion hacks

4. **React Hooks**: 
   - `useChat2` and `useChatQueries2` created but have compilation errors
   - Message persistence logic incomplete
   - State management not properly connected

**Critical Issues That Must Be Fixed:**
- ChatMessageV2 structure doesn't match UIMessage requirements
- Role enums don't convert properly between Rust and TypeScript
- Parts array conversion is broken
- No actual UI components use the new system
- Old and new systems are completely disconnected

#### Phase 1: Database Layer ‚ö†Ô∏è PARTIALLY COMPLETED
- [x] Created `chat_conversations_migration.sql` with new table structure
- [x] Created `chat_messages_v2_migration.sql` for UIMessage-compatible storage
- [x] Implemented Rust types in `chat_conversations_types.rs` and `chat_messages_v2_types.rs`
- [x] Implemented database operations in `chat_conversations_ops.rs` and `chat_messages_v2_ops.rs`
- [x] Created Tauri commands in `chats_v2.rs` with proper error handling
- [x] Registered commands in plugin system
- [x] Added exports to `crates/db-user/src/lib.rs`
- Note: Skipped indexes for now (can add later for optimization)

#### Phase 2: Transport Implementation ‚ö†Ô∏è NEEDS FIXES
- [x] Created `CustomChatTransport` class but has issues:
  - Type assertions used as workarounds (`model as any`)
  - Not verified to work with actual streamText
  - MCP tools integration copied but not tested
- [ ] Fix model type issues
- [ ] Test actual streaming behavior
- [ ] Verify tool execution flow

#### Phase 3: Hook Integration üî¥ BROKEN - NEEDS MAJOR FIXES
- [x] Created `useChat2` hook but has errors:
  - Wrong API usage for AI SDK v5
  - `submit` function parameters incorrect
  - Message persistence logic incomplete
- [x] Created `useChatQueries2` but completely broken:
  - ChatMessageV2 doesn't have `content` field (has `parts` instead)
  - Role comparison failing (enum vs string)
  - UIMessage conversion missing required `parts` field
- [ ] Fix all TypeScript compilation errors
- [ ] Implement proper message format conversion
- [ ] Test with actual data

#### Phase 4: UI Updates üìù TODO
- [ ] Update chat-view.tsx to use new hooks
- [ ] Create message-part-renderer component
- [ ] Update message-content.tsx for UIMessage structure
- [ ] Maintain exact visual styling
- [ ] Preserve all interactions

#### Current Issues to Address:
1. TypeScript errors in `useChatQueries2.ts`:
   - ChatMessageV2 doesn't have a `content` field (it has `parts` JSON)
   - Role comparison needs proper enum handling
   - UIMessage type conversion needs `parts` field

2. Integration points to verify:
   - Transport properly initializes model
   - Tool execution flows correctly
   - Streaming updates work as expected

### Migration Checklist (Current Status: üî¥ NON-FUNCTIONAL)

- [‚ö†Ô∏è] Database schema created but not tested
- [‚ö†Ô∏è] Rust operations implemented but not verified
- [‚ö†Ô∏è] Tauri commands created but not tested with frontend
- [üî¥] Custom transport has type issues and untested
- [üî¥] useChat2 hook has wrong API usage
- [üî¥] useChatQueries2 has compilation errors
- [ ] chat-view.tsx not started
- [ ] message-part-renderer not created
- [ ] message-content.tsx not updated
- [ ] Visual experience not preserved
- [ ] Performance not measured
- [ ] Tools integration not verified
- [ ] Mentions and selections not implemented
- [ ] Error handling missing
- [ ] Old files still in use
- [ ] Documentation incomplete

### Next Steps to Make This Work

1. **Fix TypeScript Errors First**:
   - Fix role enum conversions in useChatQueries2
   - Fix message parts field mapping
   - Remove type assertion hacks in transport

2. **Test Database Layer**:
   - Verify Tauri commands actually work
   - Test CRUD operations with real data
   - Ensure JSON serialization works correctly

3. **Fix Transport and Hooks**:
   - Research correct AI SDK v5 API usage
   - Implement proper message conversion
   - Test streaming behavior

4. **Then Update UI Components**:
   - Only after backend is working
   - Maintain exact UX as before

### Key Differences from Old System

1. **State Management**: useChat handles all runtime state
2. **Message Structure**: Single message with parts array instead of multiple messages
3. **Database**: Stores UIMessage format directly
4. **Streaming**: Handled by Vercel AI SDK internals
5. **Tool Calls**: Represented as message parts, not separate messages
6. **Persistence**: Simpler with onFinish callback
7. **Queries**: No complex syncing logic needed
- always use descriptive variable names